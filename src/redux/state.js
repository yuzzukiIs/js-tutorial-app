let state = {
    greetingPage: [
        {text: "Путеводитель по Java"}
    ],
    catalogPage: [
        {id: 1, theme: "Введение в Java", link:"/introduction"},
        {id: 2, theme: "Переменные", link:"/variables"},
        {id: 3, theme: "Типы данных", link:"/dataTypes"},
        {id: 4, theme: "Выражения и операторы", link:"/expressions&operators"},
        {id: 5, theme: "Условия", link:"/conditions"},
        {id: 6, theme: "Структурированные данные", link:"/structuredData"},
        {id: 7, theme: "Циклы", link:"/cycles"},
        {id: 8, theme: "Функции", link:"/functions"}
    ],
    introductionPage: [
        {id: 1, themeName: "Введение в Java"},
        {id: 2, text: "Java — это объектно-ориентированный язык программирования, разработанный компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Дата официального выпуска — 23 мая 1995 года. Программы на Java транслируются в байт-код, который затем выполняется виртуальной машиной Java (JVM). JVM — это программа, которая обрабатывает байтовый код и передает инструкции оборудованию как интерпретатор. Достоинством подобной реализации является независимость байт-кода от операционной системы и оборудования, что позволяет выполнять Java-приложения на любом устройстве, для которого существует JVM."},
        {id: 3, text: "Достоинство подобного способа выполнения программ — в полной независимости байт-кода от операционной системы и оборудования, что позволяет выполнять Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Другой важной особенностью технологии Java является гибкая система безопасности благодаря тому, что исполнение программы полностью контролируется виртуальной машиной. Любые операции, которые превышают установленные полномочия программы (например, попытка несанкционированного доступа к данным или соединения с другим компьютером) вызывают немедленное прерывание."},
        {id: 4, text: "Язык Java — язык номер один программирования бизнес-приложений. Бизнес-приложения — это многофункциональные программные системы и комплексы, предназначенные для автоматизации ключевых бизнес-функций и процессов внутри компании. Программисты бизнес-приложений получают в два раза больше программистов других приложений. Наличие таких приложений повышает эффективность ключевых бизнес-процессов предприятия, сократить сроки поиска и обработки информации, экономить материальные и человеческие ресурсы, автоматизировать типовые действия в рамках выполнения процессов и т.д."},
        {id: 5, text: "Часто к недостаткам концепции виртуальной машины относят то, что исполнение байт-кода виртуальной машиной может снижать производительность программ и алгоритмов, реализованных на языке Java. В последнее время был внесен ряд усовершенствований, которые несколько увеличили скорость выполнения программ на Java:"},
        {id: 6, text: "применение технологии трансляции байт-кода в машинный код непосредственно во время работы программы (JIT-технология) с возможностью сохранения версий класса в машинном коде,"},
        {id: 7, text: "широкое использование платформенно-ориентированного кода (native-код) в стандартных библиотеках,"},
        {id: 8, text: "аппаратные средства, обеспечивающие ускоренную обработку байт-кода (например, технология Jazelle, поддерживаемая некоторыми процессорами фирмы ARM)."},
        {id: 9, text: "Идеи, заложенные в концепцию и различные реализации среды виртуальной машины Java, вдохновили множество энтузиастов на расширение перечня языков, которые могли бы быть использованы для создания программ, исполняемых на виртуальной машине. Эти идеи нашли также выражение в спецификации общеязыковой инфраструктуры CLI, заложенной в основу платформы .NET компанией Microsoft."}
    ],  
    variablesPage: [
        {id: 1, themeName: "Переменные"},
        {id: 2, text: "Переменные – это «именованные хранилища» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных."},
        {id: 3, link: "виды объявлений переменных"},
        {id: 4, text: "Начиная с Java 10 в язык было добавлено ключевое слово var, которое также позволяет определять переменную. Слово var ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается. Например, переменной x присваивается число 10, значит, переменная будет представлять тип int. Но если переменная объявляется с помощью var, то мы обязательно должны инициализировать ее, то есть предоставить ей начальное значение, иначе мы получим ошибку."},
        {id: 5, link: "в Java существуют константы"},
        {id: 6, text: "Важно! В языке Java, как и в любом языке программирования, есть слова, которые имеют особый смысл. Например, return или if или while. Такие слова называются ключевыми (keywords) и считаются зарезервированными языком Java."},
        {id: 7, link: "список зарезервированных слов"},
        {id: 8, text: "Также важно не именовать конструкции языка именами встроенных методов языка. То есть, если вы напишете final int = значение; то непременно выйдет ошибка при компиляции языка."},
        {id: 9, title: "Области видимости переменных"},
        {id: 10, text: "У каждой переменной есть область видимости, т.е. та область программы, в которой возможна работа с этой переменной. Таким образом у переменных с одинаковыми именами не должны пересекаться области видимости. При этом областью видимости переменной будет тот блок, в котором она определена (под блоком подразумевается код, помещённый в фигурные скобки {}). У параметров область видимости – весь метод. У полей область видимости – весь класс, однако возможно создавать локальные переменные с именем, совпадающим с именем поля. В этом случае после определения данное имя будет связано именно с переменной, а не с полем класса. Это крайне не рекомендуется делать, т.к. такое определение будет создавать некоторую двусмысленность восприятия кода и может способствовать появлению ошибок."},
        {id: 11, link: "области видимости переменных"}
    ],
    dataTypesPage: [
        {id: 1, themeName: "Типы данных"},
        {id: 2, title: "В Java есть 8 типов данных:"},
        {id: 3, text: "byte - является наименьшим из целочисленных. 8-разрядный тип данных c диапазоном значений  от -2^7 до 2^7-1. Или простыми словами, может хранить значения от -128 до 127. Используется для работы с потоками ввода-вывода данных."},
        {id: 4, text: "short - 16-разрядный тип данных в диапазоне от -2^15 до 2^15-1. Может хранить значения от -32768 до 32767. Самый редко применяемый тип данных."},
        {id: 5, text: "int - наиболее часто употребляемый тип данных. Содержит 32 разряда и помещает числа в диапазоне от -2^31 до 2^31-1. Другими словами, может хранить значения от -2147483648 до 2147483647."},
        {id: 6, text: "long - 64-разрядный целочисленный тип данных с диапазоном от -2^63 до 2^63-1. Может хранить значения от -9223372036854775808 до 9223372036854775807. Удобен при работе с большими целыми числами."},
        {id: 7, text: "float - 32-разрядный тип данных с плавающей точкой. Требует в два раза меньше памяти и в некоторых процессорах выполняется быстрее, по сравнению с double. Но если значения слишком велики или слишком малы, то не обеспечивает требуемую точность вычислений. Используется когда нужно число с дробной частью, но без особой точности."},
        {id: 8, text: "double - На хранение требуется 64 бита. Рационально пользоваться double, когда нужно сохранить точность многократно повторяющихся вычислений или манипулировать большими числами."},
        {id: 9, text: "char - 16-разрядный тип данных в диапазоне от 0 до 2^16. Хранит значения от 0 до 65536. Этот тип может хранить в себе полный набор международных символов на всех известных языках мира (кодировка Unicode). То есть, по сути, каждый символ представляет из себя какое-то число. А тип данных char позволяет понять, что это число является символом."},
        {id: 10, text: "boolean - Может принимать только 2 значения true или false. Употребляется в условных выражениях. К примеру 1 > 10 вернет false, а 1 < 10 - true."},
        {id: 11, title: "Преобразование типов"},
        {id: 12, text: "Преобразование типов (или приведение типов) означает перенос данных из одного типа данных в другой. Неявное преобразование происходит, когда компилятор (для скомпилированных языков) или среда выполнения автоматически преобразует типы данных. Исходный код также может явно требовать преобразования."}
    ],
    expressionsAndOperatorsPage: [
        {id: 1, themeName: "Выражения и операторы"},
        {id: 2, title: "Операторы присваивания"},
        {id: 3, text: "В результате операции присваивания операнду(операнд это объект или проще говоря цель над которым вы проводите действия, например присваивание значения или же к примеру, сложение) слева устанавливается значение , которое берётся из правого операнда. Основным оператором присваивания является =, он присваивает значение правого операнда операнду, находящемуся слева. Таким образом, выражение x = y означает, что x имеет значение равное y."},
        {id: 4, title: "Арифметические операции"},
        {id: 5, text: "Арифметические операторы используют в качестве своих операндов числа (а также переменные и константы) и в качестве результата возвращают одно числовое значение. Стандартными арифметическими операторами являются сложение (+), вычитание (-), умножение (*), и деление (/). При работе с числами с плавающей точкой эти операторы работают аналогично их работе в большинстве других языках программирования (обратите внимание, что деление на ноль возвращает бесконечность)."},
        {id: 6, title: "Битовые(поразрядные) операции"},
        {id: 7, text: "Битовые операторы обрабатывают свои операнды как последовательности из 32 бит (нулей и единиц), а не как десятичные, шестнадцатеричные или восьмеричные числа. Например, десятичное число 9 имеет двоичное представление 1001. Битовые операторы выполняют операции над таким двоичным представлением, но результат возвращают как обычное числовое значение."},
        {id: 8, link: "битовые операторы"},
        {id: 9, title: "Логические операторы"},
        {id: 10, text: "Основные логические операции (в программировании и математике) можно применять к логическим аргументам (операндам), а также составлять более сложные выражения, подобно арифметическим действиям над числами."},
        {id: 12, link: "примеры использования"},
        {id: 13, title: "Строковые операторы"},
        {id: 14, text: "В дополнение к операторам сравнения, которые могут использоваться со строковыми значениями, оператор (+) позволяет объединить две строки, возвращая при этом третью строку, которая представляет собой объединение двух строк-операндов"},
        {id: 15, title: "Тернарный оператор"},
        {id: 16, text: "Тернарный оператор является единственным оператором JavaScript, который использует три операнда. Оператор принимает одно из двух значений в зависимости от заданного условия. "},
        {id: 17, link: "тернарный оператор"},
        {id: 18, title: "Унарный оператор"},
        {id: 19, text: "Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус - меняет знак числа на противоположный."},
        {id: 20, title: "Инкремент и декремент"},
        {id: 21, text: "Инкремент - операция увеличения операнда на 1, а декремент это операция в обратную сторону. Допустим есть переменная apples = 5; Применив инкремент(apples++) получим apples = 6;"},
        {id: 22, title: "Приоритеты операторов:"},
        {id: 23, externalLink: "https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html"}
    ],
    conditionsPage: [
        {id: 1, themeName: "Условия"},
        {id: 2, title: "Условные операторы"},
        {id: 3, text: "Условные операторы позволяют проверить некотоое условие и в зависимости от результата выполнить действия."},
        {id: 4, text: "Допустим вы заказали пиццу, вас уже её доставили. Вы сидите с друзьями и вам надо поделить пиццу поровну между собой либо заказать ещё одну пиццу. Всё зависит от количества людей. Например, если в комнате только 2 человека, то вам обеим достаётся по половине пиццы, если же вас 4, то вам достаётся по одной четвёртой куска этой пиццы.  Если вас ещё больше, вы заказываете ещё одну пиццу."},
        {id: 5, link: "операторы if, else if, else"},
        {id: 6, title: "Оператор switch"},
        {id: 7, text: "Оператор switch определяет, отвечает ли выражение тем или иным условиям, и выполняет код, если это так. Сначала этот оператор кажется очень запутанным и сложным, но основной его синтаксис аналогичен синтаксису оператора if. Он всегда записывается как switch () {}. В круглых скобках находится выражение, которое нужно оценить, а в фигурных скобках содержится код для выполнения."},
        {id: 8, link: "оператор switch"}
    ],
    structuredDatasPage: [
        {id: 1, themeName: "Структурированные данные"},
        {id: 2, text: "В Java разработчики часто тратят много времени на решение того, какую структуру данных следует использовать. Это вызвано тем, что выбор правильной структуры данных упрощает последующее управление этими данными, экономя время и упрощая понимание кода. Двумя преобладающими структурами для хранения коллекций данных являются объекты и массивы (тип объекта). Разработчики используют объекты для хранения пары ключ/значение и массивы для хранения индексированных списков."},
        {id: 3, title: "Массивы"},
        {id: 4, text: "И первая структура данных, которую нам надо рассмотреть это - массивы. Массивы представляют собой упорядоченный список данных, которыми можно управлять разнообразными способами."},
        {id: 5, link: "массивы"},
        {id: 6, title: "Объекты"},
        {id: 7, text: "Java спроектирован на основе простой парадигмы. В основе концепции лежат простые объекты. Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Значением свойства может быть функция, которую можно назвать методом объекта."},
        {id: 8, link: "объекты"},
        {id: 9, title: "Стеки"},
        {id: 10, text: "Представь себе простую ситуацию: ты живешь в гостинице, и в течение дня тебе поступали деловые письма. Поскольку тебя в это время не было в номере, служащий гостиницы просто складывал приходящие письма на твой стол. Сначала он положил на стол первое письмо. Потом пришло второе, и он положил его поверх первого. Третье пришедшее письмо он положил поверх второго, а четвертое — поверх третьего. А теперь, ответь на простой вопрос: какое письмо ты прочтешь первым, когда придешь в номер и увидишь стопку на столе? Правильно, ты прочитаешь верхнее письмо. То есть то, которое пришло последним по времени."},
        {id: 11, link: "стеки"},
        {id: 12, title: "Очереди"},
        {id: 13, text: "Очереди представляют структуру данных, работающую по принципу FIFO (first in - first out). То есть чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. Это стандартная модель однонаправленной очереди. Однако бывают и двунаправленные - то есть такие, в которых мы можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала."},
        {id: 14, link: "очереди"},
        {id: 15, title: "Связные списки"},
        {id: 16, text: "Связным списком (linked list) называется структура данных, в которой элементы упорядочены линейным образом. Сам порядок определяется не как в массивах по номерам этих самых составляющих, а указателями. Последние входят в состав элементов списка, применяются для указания на следующий «этап»."},
        {id: 17, link: "связные списки"},
        {id: 18, title: "Графы"},
        {id: 19, text: "Граф (англ. graph) — совокупность непустого множества вершин и наборов пар вершин (связей между вершинами); основной объект изучения математической теории графов. Объекты представляются как вершины или узлы графа, а связи — как дуги или рёбра."},
        {id: 20, link: "графы"},
        {id: 21, title: "Деревья"},
        {id: 22, text: "Граф состоящий из трех отдельных вершин, без ребер вообще, это все равно граф, но несвязный. Чтобы соединить в связный граф N вершин, надо минимум N-1 ребер. Такой граф называется деревом."},
        {id: 23, link: "деревья"},
        {id: 24, title: "Префиксное дерево"},
        {id: 25, text: "Префиксное дерево(Trie) — это особый вид дерева поиска, в котором для ключей узлов обычно используются строки."},
        {id: 26, link: "префиксное дерево"},
        {id: 27, title: "Хэш таблицы"},
        {id: 28, text: "Хеш-таблицы — это структура данных для хранения пар ключей и их значений. По сути она представляет собой массив, где местоположение элемента зависит от значения самого элемента. Связь между значением элемента и его позицией в хеш-таблице задает хеш-функция. Важное свойство хеш-таблицы: поиск, вставка и удаление элементов из таблицы выполняются за фиксированное время, то есть О(1), то есть они нужны тогда, когда максимально важна скорость этих операций."},
        {id: 29, link: "хэш таблицы"},
    ],
    cyclesPage: [
        {id: 1, themeName: "Циклы"},
        {id: 2, text: "Цикл - это блок кода, который способен выполнять однообразные действия до правильно указанной границы, цикл может быть бесконечным, но лучше этого не допускать."},
        {id: 3, code: "int n = 10;"},
        {id: 4, code: "ㅤfor(int i=0, j = n - 1; i < j; i++, j--){"},
        {id: 5, code: "ㅤㅤSystem.out.println(i * j);"},
        {id: 6, code: "}"},
        {id: 7, text: '"for" это непосредствуенно конструктивный элемент языка программирования Java, в котором и идут изначальное определение и порядок выполнения цикла(как правило инкремента или декремента). Дальше за фигурными скобками идут уже те действия, которые цикл должен выполнить при удовлитворительных для алгоритма условиях, пока не цикл не достигнет завершения. Но бывает, что циклы становятся бесконечными, однако этого не делают намеренно, а только по ошибке или в виду неопытности.'},
        {id: 8, code: "int j = 7;"},
        {id: 9, code: "do{"},
        {id: 10, code: "ㅤㅤSystem.out.println(j);"},
        {id: 11, code: "ㅤㅤj--;"},
        {id: 12, code: "}"},
        {id: 13, code: "while (j > 0);"},
        {id: 14, text: 'Элемент отличителен тем, что прежде чем начать цикл, всегда выполнить алгоритм один раз.'},
        {id: 15, code: "int j = 6;"},
        {id: 16, code: "while (j > 0){"},
        {id: 17, code: "ㅤㅤSystem.out.println(j);"},
        {id: 18, code: "ㅤㅤj--;"},
        {id: 19, code: "}"},
        {id: 20, text: "Цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется."}
    ],
    functionsPage: [
        {id: 1, themeName: "Функции"},
        {id: 2, text: "Функция - конструкция программы, которая выполняет код внутри своего тела и вызывается её объявлением как в другой части кода или внутри неё самой. Для работы функции нужно передать ей значения в виде её аргументов. Что примечательно, количественного ограничения для принимаемых значений функции нет, зависит от того сколько аргументов функция использует. Получив аргументы через вызов, функция выполняет инструкции внутри себя и возвращает конечный результат, в противном случае в JS функция возвращает значение “undefined”."},
        {id: 3, link: "примеры функций"}
    ],
    variablesLinkedPage: [
        {id: 1, themeName: "Виды объявлений переменных"},
        {id: 2, text:"Переменная — это контейнер, содержащий какое-либо значение. При этом под переменным значением понимают строковое, числовое или логическое значение. Само определение говорит нам о том, что переменная может изменяться по ходу выполнения программы."},
        {id: 3, text:"Существуют следующие типы переменных в Java:"},
        {id: 4, text:"1) примитивные (целые — byte, short, char, int, long; дробные или с плавающей точкой — float, double, логические — boolean);"},
        {id: 5, text:"2) ссылочные (создаются с применением конструкторов классов и нужны для доступа к объектам). "},
        {id: 6, text:"Так как Java является строго типизированным языком программирования, каждая переменная, объявляемая разработчиком, должна иметь связанный с переменным значением тип данных. "},
        {id: 7, text:"Перед использованием переменной нужно её объявить. Для объявления переменной в Java используют следующий синтаксис:"},
        {id: 8, code:"тип данных переменная [ = значение], [переменная [= значение], ...] ;"},
        {id: 9, text:"Eсли нужно объявить больше чем одну переменную указанного типа, допускается применение списка с запятыми:"},
        {id: 10, code:"int a, b, c;"},
        {id: 11, text:"Перед использованием переменной, нужно задать ей начальное значение. Этот процесс называется инициализация. Без инициализации мы можем получить ошибку во время выполнения программы, поэтому инициализация очень важна."},
        {id: 12, text:"Для инициализации переменной используют оператор присваивания. Слева указывается имя переменной, справа её значение. "},
        {id: 13, code:"int x = 10; // объявление и инициализация переменной"},
        {id: 14, code:"System.out.println(x); //10"},
        {id: 15, code:"int a = 10, b = 10  // Пример инициализации переменных"},
        {id: 16, code:"double pi = 3.14159; // Объявление переменной pi и присвоение ей величины «пи»"},
        {id: 17, code:"byte b = 22; // Инициализация переменной b типа byte"},
        {id: 18, code:"char a = 'a'; // Переменной a типа char присваиваем значение 'a'"},
        {id: 19, text:"Можно выделить 3 типа переменных:"},
        {id: 20, text:"- локальные;"},
        {id: 21, text:"- статические (переменные класса);"},
        {id: 22, text:"- переменные экземпляра."},
        {id: 23, text:"Локальные переменные в Java"},
        {id: 24, text:"Свойства локальных переменных:"},
        {id: 25, text:"- объявляются в методах, блоках или конструкторах;"},
        {id: 26, text:"- создаются, когда метод, блок или конструктор запускаются;"},
        {id: 27, text:"- уничтожаются после завершения метода, конструктора либо блока;"},
        {id: 28, text:"- видимы лишь в пределах объявленного метода, блока либо конструктора;"},
        {id: 29, text:"- реализуются на уровне стека внутри;"},
        {id: 30, text:"- в Java не существует значений по умолчанию для локальных переменных, поэтому они должны объявляться и проходить этап инициализации непосредственно перед первым использованием;"},
        {id: 31, text:"- для переменной нельзя использовать модификаторы доступа."},
        {id: 32, code:"public class Test{ "},
        {id: 33, code:"ㅤㅤpublic void pupAge(){"},
        {id: 34, code:"ㅤㅤㅤㅤint age = 0;"},
        {id: 35, code:"ㅤㅤㅤㅤage = age + 7;"},
        {id: 36, code:'ㅤㅤㅤㅤSystem.out.println("Возраст собаки: " + age);'},
        {id: 37, code:"ㅤㅤ}"},
        {id: 38, code:"ㅤㅤpublic static void main(String args[]){"},
        {id: 39, code:"ㅤㅤㅤㅤTest test = new Test();"},
        {id: 40, code:"ㅤㅤㅤㅤtest.pupAge();"},
        {id: 41, code:"ㅤㅤ}"},
        {id: 42, code:"}"},
        {id: 43, text:"По порядку стоило бы пройтись по статическим переменным, т.е. константам, однако во избежание путаницы для констант выделен отдельный раздел. По этой причине сейчас рассмотрим переменные экземпляра."},
        {id: 44, text:"Переменные экземпляра"},
        {id: 45, text:"- объявляются в классе, однако за пределами метода, блока, конструктора;"},
        {id: 46, text:"- когда в стеке выделяется пространство для объекта, создаётся слот для всех значений переменных экземпляра;"},
        {id: 47, text:"- в Java эти переменные создаются тогда, когда объект создаётся посредством ключевого слова «new», а удаляются, когда объект уничтожается;"},
        {id: 48, text:"- переменные включают значения, ссылающиеся более чем на один метод, блок или конструктор;"},
        {id: 49, text:"- переменные экземпляра можно объявить на уровне класса, а также до и после использования;"},
        {id: 50, text:"- для переменных экземпляра могут быть предоставлены модификаторы доступа;"},
        {id: 51, text:"- эти переменные в Java видимы для всех методов, блоков и конструкторов в классе. "},
        {id: 52, text:"Рекомендуется делать их приватными(private). Также можно делать их видимыми для подклассов данных переменных посредством модификаторов доступа;"},
        {id: 53, text:"- переменные имеют значения по умолчанию: 0 — для чисел, false — для логических значений, null — для ссылок на объект. Значения можно присвоить в конструкторе либо при объявлении;"},
        {id: 54, text  :"- переменные могут быть доступны при вызове имени переменной внутри класса. При этом в статических методах и разных классах они вызываются посредством полного имени — ObjectReference.VariableName."},
        {id: 55, code:"import java.io.*;"},
        {id: 56, code:""},
        {id: 57, code:"public class Employee{"},
        {id: 58, code:"ㅤㅤ// Переменная экземпляра открыта для дочернего класса (любого)"},
        {id: 59, code:"ㅤㅤpublic String name;"},
        {id: 60, code:""},
        {id: 61, code:"ㅤㅤ// Переменная salary видна лишь в Employee"},
        {id: 62, code:"ㅤㅤprivate double salary;"},
        {id: 63, code:""},
        {id: 64, code:"ㅤㅤ// Имя переменной присваивается в конструкторе "},
        {id: 65, code:"ㅤㅤpublic Employee (String empName){"},
        {id: 66, code:"ㅤㅤㅤㅤname = empName;"},
        {id: 67, code:"ㅤㅤ}"},
        {id: 68, code:""},
        {id: 69, code:"ㅤㅤ// Переменной salary присваивается значение"},
        {id: 70, code:"ㅤㅤpublic void setSalary(double empSal){"},
        {id: 71, code:"ㅤㅤㅤㅤsalary = empSal;"},
        {id: 72, code:"ㅤㅤ}"},
        {id: 73, code:""},
        {id: 74, code:"ㅤㅤ// Метод выводит на экран данные сотрудников"},
        {id: 75, code:"ㅤㅤpublic void printEmp(){"},
        {id: 76, code:'ㅤㅤㅤㅤSystem.out.println("имя: " + name );'},
        {id: 77, code:'ㅤㅤㅤㅤSystem.out.println("зарплата:" + salary);'},
        {id: 78, code:"ㅤㅤ}"},
        {id: 79, code:""},
        {id: 80, code:"ㅤㅤpublic static void main(String args[]){"},
        {id: 81, code:'ㅤㅤㅤㅤEmployee empOne = new Employee("Сергей");'},
        {id: 82, code:"ㅤㅤㅤㅤempOne.setSalary(2000);"},
        {id: 83, code:"ㅤㅤㅤㅤempOne.printEmp();"},
        {id: 84, code:"ㅤㅤ}"},
        {id: 85, code:"}"}
    ],
    constantsLinkedPage: [
        {id: 1, themeName: "Константы"},
        {id: 2, text: "Константа — постоянное значение, известное до начала работы программы и заданное в коде один раз."},
        {id: 3, text: "Почему это удобно:"},
        {id: 4, text: "Если вы используете значение многократно, а в ходе разработки его потребуется изменить, достаточно будет одной правки."},
        {id: 5, text: "Вместо длинного значения можно ставить в коде короткое имя константы."},
        {id: 6, text: "Нет риска ошибиться при очередном вводе значения."},
        {id: 7, text: "По логике это надо бы называть «постоянной» — в противоположность переменной, — но традиция уже сложилась."},
        {id: 8, text: 'Константа может хранить число, строку, символ, ссылку на объект и др. Значение константы еще называют литералом (от англ. literal — буквальный), потому что его записывают как есть — без предварительных вычислений.'},
        {id: 9, text: "При объявлении констант в Java используют ключевое слово final — оно показывает, что литерал не должен меняться. Именовать константы принято заглавными буквами со знаком подчеркивания вместо пробела."},
        {id: 10, code: 'public static final String MY_CONSTANT="текст";'},
        {id: 11, code: '//создаем строку и присваиваем ей постоянное значение'},
        {id: 12, code: 'Где хранить константы'},
        {id: 13, code: 'Новички часто спрашивают, допустимо ли держать константы в интерфейсе или обязательно раскладывать их по классам. Единого ответа нет, но логичнее хранить константы ближе к месту использования. Общие для нескольких не связанных между собой классов константы можно вынести в отдельный класс.'},
        {id: 14, text: "Здесь представлен пример применения константы в создании стрелочной функции “someFunction”.  Важно, чтобы функция всегда выполняла только те действия, которые ей предназначены и не изменялась за свои “рамки” с течением времени. Ей нужно выполнять только то, что ей положено, поэтому и при её объявлении используется ключевое слово “const”."}
    ],
    visibilityAreaLinkedPage: [
        {id: 1, themeName: "Области видимости переменных"},
        {id: 2, text: 'Область видимости переменной — свойство, которое определяет, можно ли использовать переменную из разных областей класса. Это зависит от места, где переменная была объявлена.'},
        {id: 3, text: 'Если какая-то переменная объявляется в теле метода, в цикле или условной конструкции, она исчезает после завершения работы этого метода, цикла или ветки. Это же касается и аргументов методов: переменные-аргументы существуют только в момент выполнения метода. А значит, они не могут быть доступны из других блоков кода.'},
        {id: 4, text: 'Область видимости внутри метода'},
        {id: 5, code: 'public static void main(String[] args) {'},
        {id: 6, code: 'ㅤㅤint money = 150;'},
        {id: 7, code: 'ㅤㅤint priceCappuchino = 120;'},
        {id: 8, code: 'ㅤㅤint priceEspresso = 70;'},
        {id: 9, code: 'ㅤㅤif (money >= priceCappuchino) {'},
        {id: 10, code: 'ㅤㅤㅤㅤint change = money - priceCappuchino;'},
        {id: 11, code: 'ㅤㅤㅤㅤSystem.out.println("хватает на капучино, останется " + change + "р.");'},
        {id: 12, code: 'ㅤㅤ}'},
        {id: 13, code: 'ㅤㅤif (money >= priceEspresso) {'},
        {id: 14, code: 'ㅤㅤㅤㅤint change = money - priceEspresso;'},
        {id: 15, code: 'ㅤㅤㅤㅤSystem.out.println("хватает на эспрессо, останется " + change + "р.");'},
        {id: 16, code: 'ㅤㅤ}'},
        {id: 17, code: '}'},
        {id: 18, text: 'В начале метода объявляются переменные money, priceCappuchino, priceEspresso, и инициализируются — устанавливается их значение.'},
        {id: 19, text: 'Все три переменные доступны для использования в любой строке этого метода — начиная со строки объявления переменной и заканчивая закрывающейся } метода. Это позволяет использовать эти переменные в блоках if для расчёта суммы оставшихся денег.'},
        {id: 20, text: 'Область видимости переменной начинается с момента объявления — использовать переменную до её объявления невозможно.'},
        {id: 21, text: 'Следует обращать внимание на положение фигурных скобок, которые указывают на конкретный "блок" кода с их локальными областями видимости. Переменные вне скобок блока, находятся в более "высокой" области видимости.'},
        {id: 22, text: 'Все методы, классы, функции, циклы и прочие конструктивные элементы языка подчиняются этим закономерностям.'}
    ],
    bitOperationsLinkedPage: [
        {id: 1, themeName: "Битовые операции"},
        {id: 2, code: "a = 0;//00000000000000000000000000000000"},
        {id: 3, code: "a = 1;//00000000000000000000000000000001"},
        {id: 4, code: "a = 2;//00000000000000000000000000000010"},
        {id: 5, code: "a = 3;//00000000000000000000000000000011"},
        {id: 6, code: "a=255;//00000000000000000000000011111111"},
        {id: 7, text: "Если вам не понятны наличие этих нулей и единиц, а также их порядок, то очень рекомендую почитать или посмотреть о том как хранится информация в виде битов, вам сразу станет понятно почему. На YouTube доступны лекции Гарварда CS50, не все темы подходят под обучение языка JS, но основы которые они затрагивают фундаментальны для всех программистов."},
        {id: 8, title: "Побитовое И (AND)"},
        {id: 9, code: "0 and 0 = 0;"},
        {id: 10, code: "0 and 1 = 0;"},
        {id: 11, code: "1 and 0 = 0;"},
        {id: 12, code: "1 and 1 = 1;"},
        {id: 13, title: "Приведу пример:"},
        {id: 14, code: "int a = 1;"},
        {id: 15, code: "int b = 0;"},
        {id: 16, code: "if(a & b) {"},
        {id: 17, code: "ㅤㅤconsole.log(true);"},
        {id: 18, code: "} else {"},
        {id: 19, code: "ㅤㅤconsole.log(false);"},
        {id: 20, code: "};"},
        {id: 21, text: "Если хотя бы один из сравниваемых операндов не похож, то результат всегда будет false."},
        {id: 22, title: "Побитовое ИЛИ (OR)"},
        {id: 23, text: "Принцип напоминает работы логического &, однако здесь отличие в том, что, если хотя бы один из операндов соответствует условию, то результат будет true"},
        {id: 24, code: "int a = 1;"},
        {id: 25, code: "int b = 0;"},
        {id: 26, code: "if(a | b) {"},
        {id: 27, code: "ㅤㅤconsole.log(true);"},
        {id: 28, code: "} else {"},
        {id: 29, code: "ㅤㅤconsole.log(false);"},
        {id: 30, code: "};"},
        {id: 31, title: "Побитовое исключающее ИЛИ (XOR)"},
        {id: 32, text: "Если биты сравнивающихся операндов похожи, то есть равны 1, то они принимают значение 0, а те биты которые между операндами не равны оставляют за собой прежнее значение. И вот резутатом служит преобразование битов по их схожести между операндами. Ниже есть пример:"},
        {id: 33, code: "//9 = 00001001"},
        {id: 34, code: "//14 = 00001110"},
        {id: 35, code: "//32 = 00100000"},
        {id: 36, code: "14 ^ 9 = 00000111 = 7"},
        {id: 37, code: "14 ^ 9 ^ 32 = 00100111 = 39"},
        {id: 38, title: "Побитовое НЕ (NOT)"},
        {id: 39, text: "Говоря кратко, этот оператор преобразует биты операнда в совершенно противоположный результат, то есть превращает 0 в 1, а 1 в 0. Посмотрите пример:"},
        {id: 40, code: "//9 = 00001001"},
        {id: 41, code: "//14 = 00001110"},
        {id: 42, code: "//32 = 00100000"},
        {id: 43, code: "//9 = 00001001 => 11110110 = 246"},
        {id: 44, code: "//14 = 00001110 => 11110001 = 241"},
        {id: 45, code: "//32 = 00100000 => 11011111 = 223"},
        {id: 46, title: "Битовый сдвиг влево “<<”"},
        {id: 47, code: "1 << 2 //00000001 << 2 бита для свдвига"},
        {id: 48, code: "//4 //00000100"},
        {id: 49, code: "1 << 2 << 4 //00000001 -> 00000100 ->"},
        {id: 50, code: "01000000"},
        {id: 51, code: "// порядок сдвига идёт по цепочке"},
        {id: 52, text: "Этот оператор оперирует двумя операндами(если их больше, то всё идёт по порядку). Первый операнд это число биты которого должны быть сдвинуты, а второй операнд это количество битов на которые должен сдвинуться првый операнд. Посмотрите внимательно на пример, всё станет яснее."},
        {id: 53, title: "Битовый сдвиг вправо “>>”"},
        {id: 54, text: "Принцип действия такой же как у побидового сдвига влево, только направление вправо."},
        {id: 55, title: "Правый сдвиг с заполнением нулями “>>>”"},
        {id: 56, text: "По принципу действия очень похож с побитовым сдвигом вправо, однако при работе с отрицательными числами вы поймёте между ними разницу."},
        {id: 57, code: "-128 >> 5 // -4 = 00000100"},
        {id: 58, code: "-128 >>> 5 // 134217724 ="},
        {id: 59, code: "111111111111111111111111100"},
        {id: 60, code: "//до"},
        {id: 61, code: "//-128 = 111111111111111111111111|"},
        {id: 62, code: "10000000"},
        {id: 63, code: "//после вычисления"},
        {id: 64, code: "//134217724 ="},
        {id: 65, code: "00000111111111111111111111111100"},
        {id: 66, text: "Стоит обратить внимание, что при работе с отрицательными числами, то результат всегда выходит положительным. Обратите внимание на нули, сдвиг произошёл слева направо на 5 бит."}
    ],
    logicalOperationsLinkedPage: [
        {id: 1, themeName: "Логические операторы"},
        {id: 2, text: "Логические операции выполняются с участием логических операндов. Логический операнд — это выражение, о котором можно сказать что оно является истинным или ложным, true или false. Говоря языком Java, логический операнд — это выражение типа boolean или Boolean, например: "},
        {id: 3, text: "(2 < 1) — логический операнд, его значение равно false"},
        {id: 4, text: "true — логический операнд, значение которого, очевидно, true"},
        {id: 5, text: "boolean a — тоже может быть логическим операндом, как и Boolean a"},
        {id: 6, text: "int a = 2 — не является логическим операндом, это просто переменная типа int"},
        {id: 7, text: 'String a = "true" также не является логическим операндом. Это строка, текстовое значение которой — "true".'},
        {id: 8, text: 'Оператор логического отрицания «!»"'},
        {id: 9, text: "Этот оператор — унарный, то есть он применяется к одному булевскому выражению или операнду. Понять его очень просто, как и любое отрицание: оператор просто меняет значение выражения на противоположное."},
        {id: 10, code: "public class Solution {"},
        {id: 11, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 12, code: "ㅤㅤㅤㅤboolean a = true;"},
        {id: 13, code: "ㅤㅤㅤㅤSystem.out.println(!a); // здесь наше логическое выражение меняет значение на противоположное"},
        {id: 14, code: "ㅤㅤㅤㅤSystem.out.println(!false); // выражение не-false, как можно догадаться, будет равно... чему?"},
        {id: 15, code: "ㅤㅤㅤㅤSystem.out.println(!(2 < 5)); // выражение (2 < 5) истинно, значит, его отрицание - ложно"},
        {id: 16, code: "ㅤㅤ}"},
        {id: 17, code: "}"},
        {id: 18, text: "Вывод программы будет следующий:"},
        {id: 19, code: "false"},
        {id: 20, code: "true"},
        {id: 21, code: "false"},
        {id: 22, text: "Логическое И — «&», а также условное И — «&&»"},
        {id: 23, text: "Логическое И или конъюнкцию применяют к двум выражениям, и результат его действия будет истинным (true) только если оба операнда истинны. То есть, если один из операндов a или b равен false, то выражение a & b будет false независимо от значения второго оператора."},
        {id: 24, text: "Если представить, что true — это число 1, а false — 0, то оператор & работает точно так же, как обычное умножение. Поэтому логическое И часто называют “логическим умножением”. И, кстати, этот факт помогает быстрее запомнить работу оператора & и не путать его с оператором логического или |."},
        {id: 25, code: "public class Solution {"},
        {id: 26, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 27, code: "ㅤㅤㅤㅤboolean a = true;"},
        {id: 28, code: "ㅤㅤㅤㅤboolean b = false;"},
        {id: 29, code: "ㅤㅤㅤㅤboolean c = true;"},
        {id: 30, code: "ㅤㅤㅤㅤSystem.out.println(a & b);"},
        {id: 31, code: "ㅤㅤㅤㅤSystem.out.println(a & c);"},
        {id: 32, code: "ㅤㅤㅤㅤSystem.out.println(false & (2 > 5));"},
        {id: 33, code: "ㅤㅤㅤㅤSystem.out.println((2 < 5) & false);"},
        {id: 34, code: "// независимо от правдивости выражения в скобках, в таком случае нам приходится довольствоваться ложью"},
        {id: 35, code: "ㅤㅤ}"},
        {id: 36, code: "}"},
        {id: 37, text: "Результат:"},
        {id: 38, code: "false"},
        {id: 39, code: "true"},
        {id: 40, code: "false"},
        {id: 41, code: "false"},
        {id: 42, text: "Оператор && иногда называют “сокращённым И”. Он выдаёт такой же результат при работе с логическими операндами, что и оператор &. Однако есть разница в самой его работе. Так, вы уже успели заметить, что если в выражении (a & b) операнд a равен false, то не имеет смысла проверять значение операнда b: результат операции точно будет false. Так что если нам принципиально не нужно значение второго операнда, с помощью && мы сокращаем количество вычислений в программе. Если мы заменим в примере все операторы & на &&, результат работы будет точно таким же, но сама программа будет работать чуточку быстрее (правда, мы этого не заметим, так как речь идёт о микросекундах)."},
        {id: 43, text: "Логическое ИЛИ — оператор «|», а также условное ИЛИ — оператор «||»"},
        {id: 44, text: "Оператор ИЛИ в Java обозначается символом |. Логическое ИЛИ или дизъюнкцию применяют к двум выражениям, и результат его действия будет ложным (false) тогда и только тогда, когда оба операнда ложны. Здесь мы в какой-то мере наблюдаем ту же картину, что и в случае с оператором &, но с точностью до наоборот. То есть, если хотя бы один операнд равен true, то выражение a | b гарантированно будет true независимо от значения второго оператора."},
        {id: 45, text: "Если & ведёт себя как логическое умножение, то ИЛИ — это логическое сложение, если представить, что true — это 1, а false — 0. Только следует помнить, что логическое сложение работает не так, как обычное. 1 + 1 в данном случае равно не 2, а 1 (числа 2 в этой системе просто не существует). Иногда дизъюнкцию понимают как максимум из 0 и 1, и в таком случае если хотя бы один операнд равен 1 (true), мы получим именно true. "},
        {id: 46, code: "public class Solution {"},
        {id: 47, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 48, code: "ㅤㅤㅤㅤboolean a = true;"},
        {id: 49, code: "ㅤㅤㅤㅤboolean b = false;"},
        {id: 50, code: "ㅤㅤㅤㅤboolean c = true;"},
        {id: 51, code: "ㅤㅤㅤㅤSystem.out.println(!a | b);"},
        {id: 52, code: "ㅤㅤㅤㅤSystem.out.println(a | c);"},
        {id: 53, code: "ㅤㅤㅤㅤSystem.out.println((2 < 5) | false);"},
        {id: 54, code: "ㅤㅤㅤㅤSystem.out.println((2 > 5) | true);"},
        {id: 55, code: "ㅤㅤ}"},
        {id: 56, code: "}"},
        {id: 57, text: "Результат: "},
        {id: 58, code: "false"},
        {id: 59, code: "true"},
        {id: 60, code: "true"},
        {id: 61, code: "true"},
        {id: 62, text: "Если мы применим оператор условного ИЛИ — || вместо |, мы получим ровно тот же результат, но, как и в случае с условным И &&, он будет действовать экономно: если мы “нарываемся” на первый операнд равный true, значение второго операнда не проверяется, а сразу выдаётся результат true."},
        {id: 63, text: "«XOR» Java — логическое исключающее ИЛИ — оператор «^»"},
        {id: 64, text: "XOR, сложение по модулю 2, логическое исключающее ИЛИ, логическое вычитание, строгая дизъюнкция, поразрядное дополнение… у оператора ^ есть много имён в булевой алгебре. Результат применения этого оператора к двум операндам будет равен true, если операнды разные и false, если операнды одинаковые. Поэтому его удобно сравнивать с вычитанием нулей (false) и единиц (true)."},
        {id: 65, code: "public class Solution {"},
        {id: 66, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 67, code: "ㅤㅤㅤㅤboolean a = true;"},
        {id: 68, code: "ㅤㅤㅤㅤboolean b = false;"},
        {id: 69, code: "ㅤㅤㅤㅤboolean c = true;"},
        {id: 70, code: "ㅤㅤㅤㅤSystem.out.println(!a ^ b);"},
        {id: 71, code: "ㅤㅤㅤㅤSystem.out.println(a ^ c);"},
        {id: 72, code: "ㅤㅤㅤㅤSystem.out.println((2 < 5) ^ false);"},
        {id: 73, code: "ㅤㅤㅤㅤSystem.out.println((2 > 5) ^ true);"},
        {id: 74, code: "ㅤㅤ}"},
        {id: 75, code: "}"},
        {id: 76, text: "Результат:"},
        {id: 77, code: "false"},
        {id: 78, code: "false"},
        {id: 79, code: "true"},
        {id: 80, code: "true"},
        {id: 81, text: "Краткие выводы"},
        {id: 82, text: "Все логические операторы применяются к булевским выражениям, то есть таким, о которых можно сказать, true они или false."},
        {id: 83, text: "Если операторы &, | или ^ применяются к числам, речь идёт уже не о логических операциях, а о побитовых. То есть оба числа переводятся в двоичную систему и к этим числам побитово применяют операции логического сложения, умножения или вычитания."},
        {id: 84, text: "В математической логике операторам & и | соответствуют конъюнкция и дизъюнкция."},
        {id: 85, text: "Логическое И похоже на умножения 1 (true) и 0 (false)."},
        {id: 86, text: "Логическое ИЛИ напоминает поиск максимума среди 1 (true) и 0 (false)."}
    ],
    //HERE   
    ternaryOperatorLinkedPage: [
        {id: 1, themeName: "Тернарный оператор"},
        {id: 2, text: 'Тернарный оператор является единственным условным оператором, который принимает три операнда. Это условный оператор, который обеспечивает более короткий синтаксис выражения if..else. Они компилируются в эквивалентное выражение if-else, то есть они будут точно такими же.'},
        {id: 3, code: "condition ? trueStatement : falseStatement"},
        {id: 4, text: "Условие: первая часть - это раздел условия."},
        {id: 5, text: "trueStatement: второй код, который выполняется в случае условия первой части."},
        {id: 6, text: "falseStatement: блок кода третьей части выполняется, если условие имеет значение false."},
        {id: 7, text: "Тернарный оператор использует? и: символы. Первый операнд является булевым выражением; если выражение истинно, тогда возвращается значение второго операнда, иначе возвращается значение третьего операнда. Значение переменной часто зависит от того, является ли конкретное булево выражение истинным или нет."},
        {id: 8, text: "Следующая программа Java оценивает условие, используя инструкцию if..else."},
        {id: 9, code: "int x = 20, y = 10;"},
        {id: 10, code: "if (x > y)"},
        {id: 11, code: 'ㅤㅤSystem.out.println("x is greater than y");'},
        {id: 12, code: "else"},
        {id: 13, code: 'ㅤㅤSystem.out.println("x is less than or equal to y");'},
        {id: 14, text: "То же самое мы можем сделать с тройным оператором в Java"},
        {id: 15, code: "int x = 20, y = 10;"},
        {id: 16, code: 'String result = x > y ? "x is greater than y" : "x is less than or equal to y";'},
        {id: 17, code: "public class TestClass {"},
        {id: 18, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 19, code: "ㅤㅤㅤㅤint x = 20, y = 10;"},
        {id: 20, code: 'ㅤㅤㅤㅤString result = x > y ? "x is greater than y" : "x is less than or equal to y";'},
        {id: 21, code: "ㅤㅤㅤㅤSystem.out.println(result);"},
        {id: 22, code: "ㅤㅤ}"},
        {id: 23, code: "}"},
        {id: 24, text: "Вывод в консоль:"},
        {id: 25, code: '"x is greater than y"'}
    ],
    regularConditionalOperatorsLinkedPage: [
        {id: 1, themeName: "Операторы if, else if, else"},
        {id: 2, text: "Оператор if"},
        {id: 3, text: "Оператор if совершает проверку выполняемого кода на истинность или же ложность действия."},
        {id: 4, text: "В Java оператор if может сопровождаться дополнительным оператором else, который выполняется при ложном логическое выражение."},
        {id: 5, text: "Синтаксис оператора if..else в Java следующий:"}, 
        {id: 6, code: "if(Логическое выражение){"},
        {id: 7, code: "ㅤㅤ//Выполняется, если истинно"},
        {id: 8, code: "} else {"},
        {id: 9, code: "ㅤㅤ//Выполняется, если ложно"},
        {id: 10, code: "}"},
        {id: 11, text: "Если логическое выражение истинно, то блок кода if будет выполнен, в противном случае будет выполнен блок кода else."},
        {id: 12, text: "Пример:"},
        {id: 13, code: "public class Test {"},
        {id: 14, code: "ㅤㅤpublic static void main(String args[]){"},
        {id: 15, code: "ㅤㅤㅤㅤint x = 30;"},
        {id: 16, code: "ㅤㅤㅤㅤif( x < 20 ){"},
        {id: 17, code: 'ㅤㅤㅤㅤㅤㅤSystem.out.print("Это оператор if");'},
        {id: 18, code: "ㅤㅤㅤㅤ}else{"},
        {id: 19, code: 'ㅤㅤㅤㅤㅤㅤSystem.out.print("Это оператор else");'},
        {id: 20, code: "ㅤㅤㅤㅤ}"},
        {id: 21, code: "ㅤㅤ}"},
        {id: 22, code: "}"},
        {id: 23, text: "Будет получен следующий результат:"},
        {id: 24, code: "Это оператор else"},
        {id: 25, text: "Оператор if может сопровождаться дополнительным оператором else if..else, который является очень полезным для тестирования различных условиях с использованием одного оператора if..else if."},
        {id: 26, text: "При использовании операторов if, else if, else в Java есть несколько моментов, которые необходимо иметь в виду:"},
        {id: 27, text: "if может иметь ноль или один else, который должен идти после любого if."},
        {id: 28, text: "if может иметь ноль для многих else, и он должен идти до else."},
        {id: 29, text: "после того как if...else будет успешно выполнен, из оставшихся else if или else ничто не будет выполнено (проверено)."},
        {id: 30, text: "Пример:"},
        {id: 31, code: "public class Test {"},
        {id: 32, code: "ㅤㅤpublic static void main(String args[]){"},
        {id: 33, code: "ㅤㅤㅤㅤint x = 30;"},
        {id: 34, code: "ㅤㅤㅤㅤif( x == 10 ){"},
        {id: 35, code: 'ㅤㅤㅤㅤㅤㅤSystem.out.print("Значение X = 10");'},
        {id: 36, code: "ㅤㅤㅤㅤ}else if( x == 20 ){"},
        {id: 37, code: 'ㅤㅤㅤㅤㅤㅤㅤㅤSystem.out.print("Значение X = 20");'},
        {id: 38, code: "ㅤㅤㅤㅤㅤㅤ}else if( x == 30 ){"},
        {id: 39, code: 'ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤSystem.out.print("Значение X = 30");'},
        {id: 40, code: "ㅤㅤㅤㅤㅤㅤㅤㅤ}else{"},
        {id: 41, code: 'ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤSystem.out.print("Это оператор else");'},
        {id: 42, code: "ㅤㅤㅤㅤㅤㅤㅤㅤ}"},
        {id: 43, code: "ㅤㅤ}"},
        {id: 44, code: "}"},
        {id: 45, text: "Будет получен следующий результат:"},
        {id: 46, code: "Значение X = 30"}
    ],
    switchOperatorLinkedPage: [
        {id: 1, themeName: "Операторы switch"},
        {id: 2, text: "Представьте, что вы стоите на развилке, как богатырь с известной картины. Налево пойдёшь — коня потеряешь, направо пойдешь — знания обретёшь. Как запрограммировать такую ситуацию? Вы уже, скорее всего, знаете, что подобный выбор мы совершаем с помощью конструкций if-then и if-then-else."},
        {id: 3, code: "if (turn_left) {"},
        {id: 4, code: "ㅤㅤSystem.out.println(«Коня потеряешь»);"},
        {id: 5, code: "}"},
        {id: 6, code: "if (turn_right) {"},
        {id: 7, code: "ㅤㅤSystem.out.println(“Знания обретёшь”);"},
        {id: 8, code: "}"},
        {id: 9, code: "else"},
        {id: 10, text: "ㅤㅤSystem.out.println(“Так и будешь стоять?”);"},
        {id: 11, text: "А что, если таких дорожек не две, а 10? Есть дорожка «совсем направо», «чуть левее», «ещё чуть-чуть левее» и так далее, в количестве 10 штук?"},
        {id: 12, text: "Представьте, как разрастётся ваш if-then-else код в таком варианте!"},
        {id: 13, text: "Итак, у вас не одна развилка условий, а несколько, скажем, 10 (тут важно, что число развилок ограничено). Для таких ситуаций есть специальный оператор выбора — switch case java."},
        {id: 14, code: "switch (ВыражениеДляВыбора) {"},
        {id: 15, code: "ㅤㅤcase  (Значение1):"},
        {id: 16, code: "ㅤㅤㅤㅤКод1;"},
        {id: 17, code: "ㅤㅤㅤㅤbreak;"},
        {id: 18, code: "ㅤㅤcase (Значение2):"},
        {id: 19, code: "ㅤㅤㅤㅤКод2;"},
        {id: 20, code: "ㅤㅤㅤㅤbreak;"},
        {id: 21, code: "..."},
        {id: 22, code: "ㅤㅤcase (ЗначениеN):"},
        {id: 23, code: "ㅤㅤㅤㅤКодN;"},
        {id: 24, code: "ㅤㅤㅤㅤbreak;"},
        {id: 25, code: "ㅤㅤcase (ЗначениеN):"},
        {id: 26, code: "ㅤㅤㅤㅤКодN;"},
        {id: 27, code: "ㅤㅤㅤㅤbreak;"},
        {id: 28, code: "ㅤㅤdefault:"},
        {id: 29, code: "ㅤㅤㅤㅤКодВыбораПоУмолчанию;"},
        {id: 30, code: "ㅤㅤㅤㅤbreak;"},
        {id: 31, code: "}"},
        {id: 32, text: "Порядок выполнения в операторе следующий:"},
        {id: 33, text: "Вычисляется ВыражениеДляВыбора. Далее оператор switch сравнивает полученное выражение с очередным Значением (в порядке перечисления)."},
        {id: 34, text: "Если ВыражениеДляВыбора совпало со Значением, то выполняется код, идущий после двоеточия."},
        {id: 35, text: "Если встречается конструкция break — то управление передается за пределы команды switch."},
        {id: 36, text: "Если совпадений ВыражениеДляВыбора и Значений не выявлено, то управление передаётся КодуВыбораПоУмолчанию."},
        {id: 37, text: "Тип ВыражениеДляВыбора для оператора выбора switch в Java должен быть одним из следующих:"},
        {id: 38, text: "byte, short, char, int."},
        {id: 39, text: "Их обёртки Byte, Short, Character, Integer."},
        {id: 40, text: "String (начиная с Java 7)."},
        {id: 41, text: "Перечисление (Enum)."},
        {id: 42, text: "блок default — необязательный, тогда в случае отсутствия совпадений ВыраженияДляВыбора и Значений не будет выполнено никаких действий."},
        {id: 43, text: "break не является обязательным, если его нет – код продолжит выполнение (игнорируя дальнейшие сравнения значений в блоках case) до первого встреченного break или до конца оператора switch."},
        {id: 44, text: "если необходимо выполнять один и тот же код для нескольких вариантов выбора, для исключения дублирования перед ним указываем несколько соответствующих значений в подряд идущих блоках case."},
    ],
    arraysLinkedPage: [
        {id: 1, themeName: "Массивы"},
        {id: 2, text: "Массив в Java (Java Array) — это структура данных, которая хранит набор пронумерованных значений одного типа (элементы массива)."},
        {id: 3, text: "Допустим, у нас есть класс из десяти учеников и нам нужно сохранить их оценки. Для этого можно создать десять переменных:"},
        {id: 4, code: "int mark1 = 4;"},
        {id: 5, code: "..."},
        {id: 6, code: "int mark10 = 5;"},
        {id: 7, text: "А если в нашем классе будет не десяток учеников, а в десять раз больше, не заводить же нам 100 переменных! На выручку приходят массивы."},
        {id: 8, text: "В Java массив объявляется с помощью квадратных скобок и специального слова new."},
        {id: 9, code: "тип_массива[] название_переменной = new тип_массива[размер_массива];"},
        {id: 10, text: "Тип массива может быть любым (int, Integer, String, Date, byte, char, Long и так далее)."},
        {id: 11, text: "Объявим массив типа int из 10 элементов:"},
        {id: 12, code: "int[] marks = new int[10];"},
        {id: 13, text: "При подобной инициализации все элементы массива будут иметь значение по умолчанию. Для int это 0; для float и double — 0.0; для char — \0; для boolean — false, а для String и любого другого класса это null."},
        {id: 14, text: "В Java размер массива (длина, протяжённость) определяется при объявлении, а изменить его можно только пересоздав массив."},
        {id: 15, text: "Доступ к элементам массива"},
        {id: 16, text: "Начнём с одномерного массива. Каждый элемент в нём хранится под своим индексом."},
        {id: 17, text: "Важно помнить, что в Java нумерация элементов массива начинается с 0. Поэтому индекс первого элемента равен 0, а у последнего определяется размером массива минус один."},
        {id: 18, text: "Для доступа к элементу массива указывают имя массива и номер ячейки в квадратных скобках. Например, обратимся к первому элементу массива и выведем его значение:"},
        {id: 19, code: "int[] marks = new int[10];"},
        {id: 20, code: "System.out.println(marks[0]);"},
        {id: 21, text: "Результат:"},
        {id: 22, code: "0"},
        {id: 23, text: "В консоли мы получим число 0. Почему ноль — читайте выше, в пункте про инициализацию по умолчанию."},
        {id: 24, text: "Заполним элементы массива. Для этого обратимся к каждому по индексу и присвоим значения с помощью оператора «=»:"},
        {id: 25, code: "int[] marks = new int[10];"},
        {id: 26, code: "marks[0] = 5;"},
        {id: 27, code: "marks[1] = 3;"},
        {id: 28, code: "marks[2] = 5;"},
        {id: 29, code: "marks[3] = 3;"},
        {id: 30, code: "marks[4] = 4;"},
        {id: 31, code: "marks[5] = 4;"},
        {id: 32, code: "marks[6] = 3;"},
        {id: 33, code: "marks[7] = 2;"},
        {id: 34, code: "marks[8] = 5;"},
        {id: 35, code: "marks[9] = 4;"},
        {id: 36, text: "Инициализация массива на этапе объявления"},
        {id: 37, text: "Теперь у нас есть массив, куда мы записали оценки десяти учеников. С этим уже удобнее работать, чем объявлять 10 переменных, но можно записать ещё короче:"},
        {id: 38, code: "int[] marks = new int[] {5, 3, 5, 3, 4, 4, 3, 2, 5, 4};"},
        {id: 39, text: "Мы опустили размер массива, поставили фигурные скобки после квадратных и перечислили все значения через запятую. Размер массива теперь определяется числом элементов в фигурных скобках (в нашем случае их тоже 10)."},
        {id: 40, text: "Но можно инициализировать и так:"},
        {id: 41, code: "int[] marks = {5, 3, 5, 3, 4, 4, 3, 2, 5, 4};"},
        {id: 42, text: "После знака «=» остались только фигурные скобки с перечислением значений через запятую."},
        {id: 43, text: "Чтобы управлять массивами и извлекать из них ещё большую пользу чем просто сокращение действий, существуют встроенные методы массивов. Ссылка на их список закреплена ниже. Необязательно знать абсолютно каждый метод, однако если вы освоите большую часть из них, то это может сделать вас более продвинутым в решении алгоритмических задач по сравнению с теми, кто знает всё поверхностно."},
        {id: 44, externalLink: "https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html"}
    ],
    objectsLinkedPage: [
        {id: 1, themeName: "Объекты"},
        {id: 2, text: 'Java является объектно-ориентированным языком, поэтому такие понятия как "класс" и "объект" играют в нем ключевую роль. Любую программу на Java можно представить как набор взаимодействующих между собой объектов.'},
        {id: 3, text: "Шаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке - наличие двух рук, двух ног, головы, туловища и т.д. Есть некоторый шаблон - этот шаблон можно назвать классом. Реально же существующий человек (фактически экземпляр данного класса) является объектом этого класса."},
        {id: 4, text: "Класс определяется с помощью ключевого слова сlass:"},
        {id: 5, code: "class Person{"},
        {id: 6, code: "..."},
        {id: 7, code: "}"},
        {id: 8, text: "В данном случае класс называется Person. После названия класса идут фигурные скобки, между которыми помещается тело класса - то есть его поля и методы."},
        {id: 9, text: "Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, которые может совершать объект."},
        {id: 10, text: "Для хранения состояния объекта в классе применяются поля или переменные класса. Для определения поведения объекта в классе применяются методы. Например, класс Person, который представляет человека, мог бы иметь следующее определение:"},
        {id: 11, code: "class Person{"},
        {id: 12, code: "ㅤㅤString name;        // имя"},
        {id: 13, code: "ㅤㅤint age;            // возраст"},
        {id: 14, code: "ㅤㅤvoid displayInfo(){"},
        {id: 15, code: 'ㅤㅤㅤㅤSystem.out.printf("Name: %s \tAge: %d\n", name, age);'},
        {id: 16, code: "ㅤㅤ}"},
        {id: 17, code: "}"},
        {id: 18, text: "В классе Person определены два поля: name представляет имя человека, а age - его возраст. И также определен метод displayInfo, который ничего не возвращает и просто выводит эти данные на консоль."},
        {id: 19, text: "Теперь используем данный класс. Для этого определим следующую программу:"},
        {id: 20, code: "public class Program{"},
        {id: 21, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 22, code: "ㅤㅤㅤㅤPerson tom;"},
        {id: 23, code: "ㅤㅤ}"},
        {id: 24, code: "}"},
        {id: 25, code: "class Person{"},
        {id: 26, code: "ㅤㅤString name;    // имя"},
        {id: 27, code: "ㅤㅤint age;        // возраст"},
        {id: 28, code: "ㅤㅤvoid displayInfo(){"},
        {id: 29, code: 'ㅤㅤㅤㅤSystem.out.printf("Name: %s \tAge: %d\n", name, age);'},
        {id: 30, code: "ㅤㅤ}"},
        {id: 31, code: "}"},
        {id: 32, text: "Как правило, классы определяются в разных файлах. В данном случае для простоты мы определяем два класса в одном файле. Стоит отметить, что в этом случае только один класс может иметь модификатор public (в данном случае это класс Program), а сам файл кода должен называться по имени этого класса, то есть в данном случае файл должен называться Program.java."},
        {id: 33, text: "Класс представляет новый тип, поэтому мы можем определять переменные, которые представляют данный тип. Так, здесь в методе main определена переменная tom, которая представляет класс Person. Но пока эта переменная не указывает ни на какой объект и по умолчанию она имеет значение null. По большому счету мы ее пока не можем использовать, поэтому вначале необходимо создать объект класса Person."},
        {id: 34, text: "Конструкторы"},
        {id: 35, text: "Кроме обычных методов классы могут определять специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта."},
        {id: 36, text: "Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор без параметров."},
        {id: 37, text: "Выше определенный класс Person не имеет никаких конструкторов. Поэтому для него автоматически создается конструктор по умолчанию, который мы можем использовать для создания объекта Person. В частности, создадим один объект:"},
        {id: 38, code: "public class Program{"},
        {id: 39, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 40, code: "ㅤㅤㅤㅤPerson tom = new Person(); // создание объекта"},
        {id: 41, code: "ㅤㅤㅤㅤtom.displayInfo();"},
        {id: 42, code: "ㅤㅤㅤㅤ// изменяем имя и возраст"},
        {id: 43, code: 'ㅤㅤㅤㅤtom.name = "Tom";'},
        {id: 44, code: "ㅤㅤㅤㅤtom.age = 34;"},
        {id: 45, code: "ㅤㅤㅤㅤtom.displayInfo();"},
        {id: 46, code: "ㅤㅤ}"},
        {id: 47, code: "}"},
        {id: 48, code: "class Person{"},
        {id: 49, code: "ㅤㅤString name;    // имя"},
        {id: 50, code: "ㅤㅤint age;        // возраст"},
        {id: 51, code: "ㅤㅤvoid displayInfo(){"},
        {id: 52, code: 'ㅤㅤㅤㅤSystem.out.printf("Name: %s \tAge: %d\n", name, age);'},
        {id: 53, code: "ㅤㅤ}"},
        {id: 54, code: "}"},
        {id: 55, text: "Для создания объекта Person используется выражение new Person(). Оператор new выделяет память для объекта Person. И затем вызывается конструктор по умолчанию, который не принимает никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта Person. А переменная tom получит ссылку на созданный объект."},
        {id: 56, text: "Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. Для переменных числовых типов это число 0, а для типа string и классов - это значение null (то есть фактически отсутствие значения)."},
        {id: 57, text: 'После создания объекта мы можем обратиться к переменным объекта Person через переменную tom и установить или получить их значения, например, tom.name = "Tom".'},
        {id: 58, text: "В итоге мы увидим на консоли:"},
        {id: 59, code: "Name: nullㅤㅤㅤㅤAge: 0"},
        {id: 60, code: "Name: TomㅤㅤㅤㅤAge: 34"},
        {id: 61, text: "Если необходимо, чтобы при создании объекта производилась какая-то логика, например, чтобы поля класса получали какие-то определенные значения, то можно определить в классе свои конструкторы. Например:"},
        {id: 62, code: "public class Program{"},
        {id: 63, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 64, code: "ㅤㅤㅤㅤPerson bob = new Person();      // вызов первого конструктора без параметров"},
        {id: 65, code: "ㅤㅤㅤㅤbob.displayInfo();"},
        {id: 66, code: 'ㅤㅤㅤㅤPerson tom = new Person("Tom"); // вызов второго конструктора с одним параметром'},
        {id: 67, code: "ㅤㅤㅤㅤtom.displayInfo();"},
        {id: 68, code: 'ㅤㅤㅤㅤPerson sam = new Person("Sam", 25); // вызов третьего конструктора с двумя параметрами'},
        {id: 69, code: "ㅤㅤㅤㅤsam.displayInfo();"},
        {id: 70, code: "ㅤㅤ}"},
        {id: 71, code: "}"},
        {id: 72, code: "class Person{"},
        {id: 73, code: "ㅤㅤString name;    // имя"},
        {id: 74, code: "ㅤㅤint age;        // возраст"},
        {id: 75, code: "ㅤㅤPerson()"},
        {id: 76, code: "ㅤㅤ{"},
        {id: 77, code: 'ㅤㅤㅤㅤname = "Undefined";'},
        {id: 78, code: "ㅤㅤㅤㅤage = 18;"},
        {id: 79, code: "ㅤㅤ}"},
        {id: 80, code: "ㅤㅤPerson(String n)"},
        {id: 81, code: "ㅤㅤ{"},
        {id: 82, code: "ㅤㅤㅤㅤname = n;"},
        {id: 83, code: "ㅤㅤㅤㅤage = 18;"},
        {id: 84, code: "ㅤㅤ}"},
        {id: 85, code: "ㅤㅤPerson(String n, int a)"},
        {id: 86, code: "ㅤㅤ{"},
        {id: 87, code: "ㅤㅤㅤㅤname = n;"},
        {id: 88, code: "ㅤㅤㅤㅤage = a;"},
        {id: 89, code: "ㅤㅤ}"},
        {id: 90, code: "ㅤㅤvoid displayInfo(){"},
        {id: 91, code: 'ㅤㅤㅤㅤSystem.out.printf("Name: %s \tAge: %d\n", name, age);'},
        {id: 92, code: "ㅤㅤ}"},
        {id: 93, code: "}"},
        {id: 94, text: "Теперь в классе определено три коструктора, каждый из которых принимает различное количество параметров и устанавливает значения полей класса."},
        {id: 95, text: "Консольный вывод программы:"},
        {id: 96, code: "Name: UndefinedㅤㅤㅤㅤAge: 18"},
        {id: 97, code: "Name: Tom	ㅤㅤㅤㅤAge: 18"},
        {id: 98, code: "Name: SamㅤㅤㅤㅤAge: 25"},
        {id: 99, text: "Ключевое слово this"},
        {id: 100, text: "Ключевое слово this представляет ссылку на текущий экземпляр класса. Через это ключевое слово мы можем обращаться к переменным, методам объекта, а также вызывать его конструкторы. Например:"},
        {id: 101, code: "public class Program{"},
        {id: 102, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 103, code: "ㅤㅤㅤㅤPerson undef = new Person();"},
        {id: 104, code: "ㅤㅤㅤㅤundef.displayInfo();"},
        {id: 105, code: 'ㅤㅤㅤㅤPerson tom = new Person("Tom");'},
        {id: 106, code: "ㅤㅤㅤㅤtom.displayInfo();"},
        {id: 107, code: 'ㅤㅤㅤㅤPerson sam = new Person("Sam", 25);'},
        {id: 108, code: "ㅤㅤㅤㅤsam.displayInfo();"},
        {id: 109, code: "ㅤㅤ}"},
        {id: 110, code: "}"},
        {id: 111, code: "class Person{"},
        {id: 112, code: "ㅤㅤString name;    // имя"},
        {id: 113, code: "ㅤㅤint age;        // возраст"},
        {id: 114, code: "ㅤㅤPerson()"},
        {id: 115, code: "ㅤㅤ{"},
        {id: 116, code: 'ㅤㅤㅤㅤthis("Undefined", 18);'},
        {id: 117, code: "ㅤㅤ}"},
        {id: 118, code: "ㅤㅤㅤㅤPerson(String name)"},
        {id: 119, code: "ㅤㅤ{"},
        {id: 120, code: "ㅤㅤㅤㅤthis(name, 18);"},
        {id: 121, code: "ㅤㅤ}"},
        {id: 122, code: "ㅤㅤㅤㅤPerson(String name, int age)"},
        {id: 123, code: "ㅤㅤ{"},
        {id: 124, code: "ㅤㅤㅤㅤthis.name = name;"},
        {id: 125, code: "ㅤㅤㅤㅤthis.age = age;"},
        {id: 126, code: "ㅤㅤ}"},
        {id: 127, code: "ㅤㅤvoid displayInfo(){"},
        {id: 128, code: 'ㅤㅤㅤㅤSystem.out.printf("Name: %s \tAge: %d\n", name, age);'},
        {id: 129, code: "ㅤㅤ}"},
        {id: 130, code: "}"},
        {id: 131, text: "В третьем конструкторе параметры называются так же, как и поля класса. И чтобы разграничить поля и параметры, применяется ключевое слово this:"},
        {id: 132, code: "this.name = name;"},
        {id: 133, text: "Так, в данном случае указываем, что значение параметра name присваивается полю name."},
        {id: 134, text: "Кроме того, у нас три конструктора, которые выполняют идентичные действия: устанавливают поля name и age. Чтобы избежать повторов, с помощью this можно вызвать один из конструкторов класса и передать для его параметров необходимые значения:"},
        {id: 135, code: "Person(String name)"},
        {id: 136, code: "{"},
        {id: 137, code: "ㅤㅤthis(name, 18);"},
        {id: 138, code: "}"},
        {id: 139, text: "В итоге результат программы будет тот же, что и в предыдущем примере."},
        {id: 140, text: "Инициализаторы"},
        {id: 141, text: "Кроме конструктора начальную инициализацию объекта вполне можно было проводить с помощью инициализатора объекта. Инициализатор выполняется до любого конструктора. То есть в инициализатор мы можем поместить код, общий для всех конструкторов:"},
        {id: 142, code: "public class Program{"},
        {id: 143, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 144, code: 'ㅤㅤㅤㅤPerson undef = new Person();'},
        {id: 145, code: "ㅤㅤㅤㅤundef.displayInfo();"},
        {id: 146, code: 'ㅤㅤㅤㅤPerson tom = new Person("Tom");'},
        {id: 147, code: "ㅤㅤㅤㅤtom.displayInfo();"},
        {id: 148, code: "ㅤㅤ}"},
        {id: 149, code: "}"},
        {id: 150, code: "class Person{"},
        {id: 151, code: "ㅤㅤString name;    // имя"},
        {id: 152, code: "ㅤㅤint age;  // возраст"},
        {id: 153, code: "ㅤㅤ/*начало блока инициализатора*/"},
        {id: 154, code: "ㅤㅤ{"},
        {id: 155, code: 'ㅤㅤㅤㅤname = "Undefined";'},
        {id: 156, code: "ㅤㅤㅤㅤage = 18;"},
        {id: 157, code: "ㅤㅤ}"},
        {id: 158, code: "ㅤㅤ/*конец блока инициализатора*/"},
        {id: 159, code: "ㅤㅤPerson(){"},
        {id: 160, code: "ㅤㅤ}"},
        {id: 161, code: "ㅤㅤㅤㅤPerson(String name){"},
        {id: 162, code: "ㅤㅤㅤㅤthis.name = name;"},
        {id: 163, code: "ㅤㅤ}"},
        {id: 164, code: "ㅤㅤPerson(String name, int age){"},
        {id: 165, code: "ㅤㅤㅤㅤthis.name = name;"},
        {id: 166, code: "ㅤㅤㅤㅤthis.age = age;"},
        {id: 167, code: "ㅤㅤ}"},
        {id: 168, code: "ㅤㅤㅤㅤvoid displayInfo(){"},
        {id: 169, code: 'ㅤㅤㅤㅤSystem.out.printf("Name: %s \tAge: %d\n", name, age);'},
        {id: 170, code: "ㅤㅤ}"},
        {id: 171, code: "}"},
        {id: 172, text: "Вывод в консоли:"},
        {id: 173, code: "Name: UndefinedㅤㅤAge: 18"},
        {id: 174, code: "Name: TomㅤㅤTomAge: 18"}
    ],
    stacksLinkedPage: [
        {id: 1, themeName: "Стеки"},
        {id: 2, text: "Stack — это линейная структура данных, которая следует принципу LIFO (последний пришел, первый ушел). Это означает, что объекты могут быть вставлены или удалены только с одного конца, также называемого вершиной."},
        {id: 3, text: "Stack поддерживает следующие операции:"},
        {id: 4, text: "push вставляет элемент на вершину stack (т. е. над его текущим верхним элементом)."},
        {id: 5, text: "pop удаляет объект из вершины stack и возвращает этот объект из функции. Размер stack будет уменьшен на единицу."},
        {id: 6, text: "isEmpty проверяет, пуст stack или нет."},
        {id: 7, text: "isFull проверяет, заполнен ли stack или нет."},
        {id: 8, text: "peek возвращает объект наверху stack, не удаляя его из stack и не изменяя стек каким-либо образом."},
        {id: 9, text: "size возвращает общее количество элементов, присутствующих в stack."},
        {id: 10, text: "Особенности стека:"},
        {id: 11, text: "Он заполняется и освобождается по мере вызова и завершения новых методов."},
        {id: 12, text: "Переменные в стеке существуют до тех пор, пока выполняется метод в котором они были созданы."},
        {id: 13, text: "Если память стека будет заполнена, Java бросит исключение java.lang.StackOverFlowError"},
        {id: 14, text: "Доступ к этой области памяти осуществляется быстрее, чем к куче."},
        {id: 15, text: "Является потокобезопасным, поскольку для каждого потока создается свой отдельный стек."},
        {id: 16, code: "public class Cat {"},
        {id: 17, code: "ㅤㅤprivate String mName;"},
        {id: 18, code: "ㅤㅤprivate int mAge;"},
        {id: 19, code: "ㅤㅤpublic Cat(String name, int age) {"},
        {id: 20, code: "ㅤㅤㅤㅤmName = name;"},
        {id: 21, code: "ㅤㅤㅤㅤmAge = age;"},
        {id: 22, code: "ㅤㅤ}"},
        {id: 23, code: "ㅤㅤ@Override"},
        {id: 24, code: "ㅤㅤpublic String toString() {"},
        {id: 25, code: "ㅤㅤㅤㅤreturn this.mName;"},
        {id: 26, code: "ㅤㅤ}"},
        {id: 27, code: "}"},
        {id: 28, text: 'Представьте себе, что имеется длинная узкая труба, запаянная с одного конца. Мы заталкиваем в трубу пушистого друга, поэтому метод называется "пуш" (push()). А чтобы вытащить кота, хватаем его за попу (метод pop()). Давайте запихаем в трубу трёх котов, а потом вытащим их.'},
        {id: 29, code: 'Cat barsik = new Cat("Барсик", 4);'},
        {id: 30, code: 'Cat murzik = new Cat("Мурзик", 6);'},
        {id: 31, code: 'Cat vaska = new Cat("Васька", 9);'},
        {id: 32, code: "Stack<Cat> catStack = new Stack<>();"},
        {id: 33, code: "catStack.push(barsik);"},
        {id: 34, code: "catStack.push(murzik);"},
        {id: 35, code: "catStack.push(vaska);"},
        {id: 36, code: 'Log.i(TAG, "Текущий стек: " + catStack);'},
        {id: 37, code: 'Log.i(TAG, "Брысь " + catStack.pop());'},
        {id: 38, code: 'Log.i(TAG, "Кто последний? " + catStack.peek().toString());'},
        {id: 39, code: 'Log.i(TAG, "Брысь " + catStack.pop());'},
        {id: 40, code: 'Log.i(TAG, "Кто последний? " + catStack.peek().toString());'},
        {id: 41, code: 'Log.i(TAG, "Брысь " + catStack.pop());'},
        {id: 42, code: 'Log.i(TAG, "Никого? " + catStack.empty());'},
        {id: 43, code: "try {"},
        {id: 44, code: 'ㅤㅤLog.i(TAG, "Кто последний? " + catStack.peek().toString());'},
        {id: 45, code: "}catch (EmptyStackException e)"},
        {id: 46, code: "{"},
        {id: 47, code: 'ㅤㅤLog.i(TAG, "Пустой стек. Некого прогонять");'},
        {id: 48, code: "}"},
        {id: 49, text: "У нас есть три кота - Барсик, Мурзик и Васька. В такой последовательности мы их запихнули в трубу и проверяем текущий стек."},
        {id: 50, code: "Текущий стек: [Барсик, Мурзик, Васька]"},
        {id: 51, text: "Вызываем метод pop() первый раз. Как видите, мы не указываем позицию элемента, так стек работает только с последним элементом. Последним был Васька. Чтобы узнать, кто теперь последний в стеке, не удаляя его оттуда, нужно вызвать метод peek()."},
        {id: 52, code: "Брысь Васька"},
        {id: 53, code: "Кто последний? Мурзик"},
        {id: 54, text: "Повторяем этот шаг ещё раз и вытаскиваем кота Мурзика. Затем и Барсика."},
        {id: 55, code: "Брысь Мурзик"},
        {id: 56, code: "Кто последний? Барсик"},
        {id: 57, code: "Брысь Барсик"},
        {id: 58, text: "Чтобы убедиться, что в трубе никого не осталось, вызываем метод empty(), который возвращает булево значение."},
        {id: 59, code: "Никого? true"},
        {id: 60, text: "Если при пустом стеке вызвать методы pop() или peek(), то программа закроется с ошибкой. Чтобы избежать подобной ситуации, нужно обработать исключение EmptyStackException. Тогда программа будет работать без сбоев."},
        {id: 61, text: "Пустой стек. Некого прогонять"},
        {id: 62, text: "В конце выводим информацию о пустом стеке."},
        {id: 63, code: "Текущий стек: []"},
        {id: 64, text: "У класса также есть метод int search(Object o), который ищет заданный элемент в стеке, возвращая количество операций pop(), которые требуются для того чтобы перевести искомый элемент в вершину стека. Если заданный элемент в стеке отсутствует, этот метод возвращает -1."},
        {id: 65, text: "Надеюсь, вы поняли что такое стек. Пожалуйста, не загоняйте котов в трубу."}
    ],
    queuesLinkedPage: [
        {id: 1, themeName: "Очереди"},
        {id: 2, text: "Очереди представляют структуру данных, работающую по принципу FIFO (first in - first out). То есть чем раньше был добавлен элемент в коллекцию, тем раньше он из нее удаляется. Это стандартная модель однонаправленной очереди. Однако бывают и двунаправленные - то есть такие, в которых мы можем добавить элемент не только в начала, но и в конец. И соответственно удалить элемент не только из конца, но и из начала."},
        {id: 3, text: "Особенностью классов очередей является то, что они реализуют специальные интерфейсы Queue или Deque."},
        {id: 4, text: "Интерфейс Queue"},
        {id: 5, text: "E element(): возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 6, text: "boolean offer(E obj): добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false"},
        {id: 7, text: "E peek(): возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null"},
        {id: 8, text: "E poll(): возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null"},
        {id: 9, text: "E remove(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 10, text: "Таким образом, у всех классов, которые реализуют данный интерфейс, будет метод offer для добавления в очередь, метод poll для извлечения элемента из головы очереди, и методы peek и element, позволяющие просто получить элемент из головы очереди."},
        {id: 11, text: "Интерфейс Deque"},
        {id: 12, text: "Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (последний вошел - первый вышел)."},
        {id: 13, text: "Интерфейс Deque определяет следующие методы:"},
        {id: 14, text: "void addFirst(E obj): добавляет элемент в начало очереди"},
        {id: 15, text: "void addLast(E obj): добавляет элемент obj в конец очереди"},
        {id: 16, text: "E getFirst(): возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 17, text: "E getLast(): возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 18, text: "boolean offerFirst(E obj): добавляет элемент obj в самое начало очереди. Если элемент удачно добавлен, возвращает true, иначе - false"},
        {id: 19, text: "boolean offerLast(E obj): добавляет элемент obj в конец очереди. Если элемент удачно добавлен, возвращает true, иначе - false"},
        {id: 20, text: "E peekFirst(): возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение null"},
        {id: 21, text: "E peekLast(): возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение null"},
        {id: 22, text: "E pollFirst(): возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение null"},
        {id: 23, text: "E pollLast(): возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение null"},
        {id: 24, text: "E pop(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 25, text: "void push(E element): добавляет элемент в самое начало очереди"},
        {id: 26, text: "E removeFirst(): возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 27, text: "E removeLast(): возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение NoSuchElementException"},
        {id: 28, text: "boolean removeFirstOccurrence(Object obj): удаляет первый встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false."},
        {id: 29, text: "boolean removeLastOccurrence(Object obj): удаляет последний встреченный элемент obj из очереди. Если удаление произшло, то возвращает true, иначе возвращает false."},
        {id: 30, text: "Таким образом, наличие методов pop и push позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими."},
        {id: 31, text: "Класс ArrayDeque"},
        {id: 32, text: "В Java очереди представлены рядом классов. Одни из низ - класс ArrayDeque<E>. Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса AbstractCollection и применяя интерфейс Deque."},
        {id: 33, text: "В классе ArrayDeque определены следующие конструкторы:"},
        {id: 34, text: "ArrayDeque(): создает пустую очередь"},
        {id: 35, text: "ArrayDeque(Collection<? extends E> col): создает очередь, наполненную элементами из коллекции col"},
        {id: 36, text: "ArrayDeque(int capacity): создает очередь с начальной емкостью capacity. Если мы явно не указываем начальную емкость, то емкость по умолчанию будет равна 16"},
        {id: 37, text: "Пример использования класса:"},
        {id: 38, code: "import java.util.ArrayDeque;"},
        {id: 39, code: "public class Program{"},
        {id: 40, code: "ㅤㅤpublic static void main(String[] args) {"},
        {id: 41, code: "ㅤㅤㅤㅤArrayDeque<String> states = new ArrayDeque<String>();"},
        {id: 42, code: "ㅤㅤㅤㅤ// стандартное добавление элементов"},
        {id: 43, code: 'ㅤㅤㅤㅤstates.add("Germany");'},
        {id: 44, code: 'ㅤㅤㅤㅤstates.addFirst("France"); // добавляем элемент в самое начало'},
        {id: 45, code: 'ㅤㅤㅤㅤstates.push("Great Britain"); // добавляем элемент в самое начало'},
        {id: 46, code: 'ㅤㅤㅤㅤstates.addLast("Spain"); // добавляем элемент в конец коллекции'},
        {id: 47, code: 'ㅤㅤㅤㅤstates.add("Italy");'},
        {id: 48, code: "ㅤㅤㅤㅤ// получаем первый элемент без удаления"},
        {id: 49, code: "ㅤㅤㅤㅤString sFirst = states.getFirst();"},
        {id: 50, code: "ㅤㅤㅤㅤSystem.out.println(sFirst);     // Great Britain"},
        {id: 51, code: "ㅤㅤㅤㅤ// получаем последний элемент без удаления"},
        {id: 52, code: "ㅤㅤㅤㅤString sLast = states.getLast();"},
        {id: 53, code: "ㅤㅤㅤㅤSystem.out.println(sLast);      // Italy"},
        {id: 54, code: 'ㅤㅤㅤㅤSystem.out.printf("Queue size: %d \n", states.size());  // 5'},
        {id: 55, code: "ㅤㅤㅤㅤ// перебор коллекции"},
        {id: 56, code: "ㅤㅤㅤㅤwhile(states.peek()!=null){"},
        {id: 57, code: "ㅤㅤㅤㅤㅤㅤ// извлечение c начала"},
        {id: 58, code: "ㅤㅤㅤㅤㅤㅤSystem.out.println(states.pop());"},
        {id: 59, code: "ㅤㅤㅤㅤ}"},
        {id: 60, code: "ㅤㅤㅤㅤ// очередь из объектов Person"},
        {id: 61, code: "ㅤㅤㅤㅤArrayDeque<Person> people = new ArrayDeque<Person>();"},
        {id: 62, code: 'ㅤㅤㅤㅤpeople.addFirst(new Person("Tom"));'},
        {id: 63, code: 'ㅤㅤㅤㅤpeople.addLast(new Person("Nick"));'},
        {id: 64, code: "ㅤㅤㅤㅤ// перебор без извлечения"},
        {id: 65, code: "ㅤㅤㅤㅤfor(Person p : people){"},
        {id: 66, code: "ㅤㅤㅤㅤㅤㅤSystem.out.println(p.getName());"},
        {id: 67, code: "ㅤㅤㅤㅤ}"},
        {id: 68, code: "ㅤㅤ}"},
        {id: 69, code: "}"},
        {id: 70, code: "class Person{"},
        {id: 71, code: "ㅤㅤprivate String name;"},
        {id: 72, code: "ㅤㅤpublic Person(String value){"},
        {id: 73, code: "ㅤㅤㅤㅤname=value;"},
        {id: 74, code: "ㅤㅤ}"},
        {id: 75, code: "ㅤㅤString getName(){return name;}"},
        {id: 76, code: "}"}
    ],
    linkedListsLinkedPage: [
        {id: 1, themeName: "Связные списки"},
        {id: 2, text: "Связным списком (linked list) называется структура данных, в которой элементы упорядочены линейным образом. Сам порядок определяется не как в массивах по номерам этих самых составляющих, а указателями. Последние входят в состав элементов списка, применяются для указания на следующий «этап»."},
        {id: 3, text: "Должен содержать две «детали»:"},
        {id: 4, text: "голову;"},
        {id: 5, text: "хвост."},
        {id: 6, text: "Без этих составляющих списки линейного типа немыслимы."},
        {id: 7, text: "Плюсы и минусы перед массивами"},
        {id: 8, text: "Корректировка связных элементов осуществляется за постоянное время (0(1)), чего нет в массивах. Может с легкостью расширяться. Для этого достаточно добавить очередной элемент."},
        {id: 9, text: "Но перед использованием соответствующей составляющей языка важно помнить: для поиска конкретного «предмета» требуется каждый раз проходить весь список. Время доступа к искомому = O (n)."},
        {id: 10, text: "Узлы"},
        {id: 11, text: "Новый узел (new node) – это элемент линейного списка. Содержит информацию, подлежащую дальнейшему сохранению, а также указатель на следующий элемент в «перечне» или значение NULL, если рассматриваемая «часть» является последней."},
        {id: 12, text: "В приведенном примере описан код структуры, реализующий элемент связного списка (и всей «конструкции» тоже). Информация представляется числовыми данными."},
        {id: 13, text: "Простыми словами: синтаксис структуры для создания собственного типа информации для инкапсуляции узлов активно используется программистом. Здесь:"},
        {id: 14, text: "Int n – сведения, которые хочется сохранить в узле;"},
        {id: 15, text: "struct node*next – указатель на следующую составляющую в списке;"},
        {id: 16, text: "typedef-ed – не присваивается до выполнения соответствующих строк."},
        {id: 17, text: "Так, сначала записывается узел struct вместо предыдущего элемента перед и внутри фигурных скобочек. В последней строчке предоставляется node для tupedef в качестве имени, используемого для очередного типа данных оставшейся части приложения."},
        {id: 18, text: "Односвязные"},
        {id: 19, text: "Односвязные списки – такие объекты, которые включают в себя «маркеры»-указатели на следующий узел. Из точки А можно попасть лишь в точку Б. Так пользователь будет двигаться в самый конец перечня. То есть, пошагово, последовательно."},
        {id: 20, text: "Вследствие происходит образование потоков, текущих в одном заданном направлении. Полем указателя последнего элемента служит нулевое значение. То есть, NULL."},
        {id: 21, text: "Основные манипуляции, осуществляемые посредством ОЛС:"},
        {id: 22, text: "инициализация;"},
        {id: 23, text: "добавление новых элементов в перечень;"},
        {id: 24, text: "удаление узлов и корней;"},
        {id: 25, text: "вывод составляющих списка;"},
        {id: 26, text: "взаимообмен нескольких «частей» перечня."},
        {id: 27, text: "Далее будут рассмотрены все эти операции с примерами кодов для большей наглядности."},
        {id: 28, text: "Инициализация"},
        {id: 29, text: "Операция необходима для того, чтобы создавать корневые узлы списков, у которых поля с указателями на следующие составляющие обладают нулевым значением:"},
        {id: 30, code: "struct list * init(int Z) // Z- информация в первом узле"},
        {id: 31, code: "{"},
        {id: 32, code: "ㅤㅤstruct list *lst;"},
        {id: 33, code: "ㅤㅤ// осуществление выделения необходимой памяти для дальнейшей работы"},
        {id: 34, code: "ㅤㅤlst = (struct list*)malloc(sizeof(struct list));"},
        {id: 35, code: "ㅤㅤlst->field = Z;"},
        {id: 36, code: "ㅤㅤlst->ptr = NULL; // обозначение последнего узла"},
        {id: 37, code: "ㅤㅤreturn(lst);"},
        {id: 38, code: "}"},
        {id: 39, text: "Это – самый простой вариант развития событий. Но в процессе работы пригодятся и другие манипуляции."},
        {id: 40, text: "Добавление"},
        {id: 41, text: "При добавлении элементов в списки функциям присваиваются следующие аргументы:"},
        {id: 42, text: "информация для добавляемой составляющей;"},
        {id: 43, text: "непосредственный указатель на задействованный элемент."},
        {id: 44, text: "Проводится в несколько этапов. Сначала создается добавляемый узел и заполняются его поля информации. Затем переустанавливаются предыдущие указатели на тот, что хочется внедрить. Завершающим этапом является установка указателей добавляемого элемента туда, куда «показывал» прошлый узел."},
        {id: 45, code: "struct list * addelem(list *lst, int number)"},
        {id: 46, code: "{"},
        {id: 47, code: "ㅤㅤstruct list *temp, *p;"},
        {id: 48, code: "ㅤㅤtemp = (struct list*)malloc(sizeof(list));"},
        {id: 49, code: "ㅤㅤp = lst->ptr; // сохранение «маркера» на последующий «объект»"},
        {id: 50, code: "ㅤㅤlst->ptr = temp; // указание предыдущим элементом на новый"},
        {id: 51, code: "ㅤㅤtemp->field = number; // поля данных нового элемента сохраняются в память"},
        {id: 52, code: "ㅤㅤtemp->ptr = p; // указание созданным узлом на предыдущий элемент"},
        {id: 53, code: "ㅤㅤreturn(temp);"},
        {id: 54, text: "Адрес добавленного узла – возвращаемое значение задействованной функции."},
        {id: 55, text: "Удаление"},
        {id: 56, text: "При удалении элементов ОЛС функциями аргументов служат указатели на подлежащий стиранию «объект», а также «маркер» его корня. Функции возвращают указатель на элемент, который следует за удаленным."},
        {id: 57, text: "Тоже проводится в несколько шагов:"},
        {id: 58, text: "постановка указателя предыдущей составляющей на следующий за тем, что подлежит деинсталляции;"},
        {id: 59, text: "высвобождение памяти устройства."},
        {id: 60, text: "Код будет примерно следующим:"},
        {id: 61, code: "struct list * deletelem(list *lst, list *root)"},
        {id: 62, codet: "{"},
        {id: 63, code: "ㅤㅤstruct list *temp;"},
        {id: 64, code: "ㅤㅤtemp = root;"},
        {id: 65, code: "ㅤㅤwhile (temp->ptr != lst) // список с корня просматривается с самого начала"},
        {id: 66, code: "ㅤㅤ{ // изучение до тех пор, пока не обнаружена «часть», предшествующая lst"},
        {id: 67, code: "ㅤㅤtemp = temp->ptr;"},
        {id: 68, code: "ㅤㅤ}"},
        {id: 69, code: "ㅤㅤtemp->ptr = lst->ptr; // перестановка маркера в новое место"},
        {id: 70, code: "ㅤㅤfree(lst); // освобождение положенной части памяти"},
        {id: 71, code: "ㅤㅤreturn(temp);"},
        {id: 72, code: "}"},
        {id: 73, text: "В случае со стиранием корней ситуация обстоит иначе:"},
        {id: 74, code: "struct list * deletehead(list *root)"},
        {id: 75, code: "{"},
        {id: 76, code: "ㅤㅤstruct list *temp;"},
        {id: 77, code: "ㅤㅤtemp = root->ptr;"},
        {id: 78, code: "ㅤㅤfree(root); // высвобождается память корня, который удаляли"},
        {id: 79, code: "ㅤㅤreturn(temp); // создание нового корня"},
        {id: 80, code: "}"},
        {id: 81, text: "Функции удаления корней в списках в виде аргументов получают указатели на текущие корни перечней. Возвращаемое значение – новый корень. А именно – узел, на который указывал удаленный."},
        {id: 82, text: "Вывод"},
        {id: 83, text: "Отобразить элемент списка можно следующим макаром:"},
        {id: 84, code: "void listprint(list *lst)"},
        {id: 85, code: "{"},
        {id: 86, code: "ㅤㅤstruct list *p;"},
        {id: 87, code: "ㅤㅤp = lst;"},
        {id: 88, code: "ㅤㅤdo {"},
        {id: 89, code: 'ㅤㅤㅤㅤprintf("%d ", p->field); // выводится значение, присвоенное ранее p'},
        {id: 90, code: "ㅤㅤㅤㅤp = p->ptr; // осуществляется переход к следующей составляющей"},
        {id: 91, code: "ㅤㅤ} while (p != NULL);"},
        {id: 92, code: "}"},
        {id: 93, text: "Аргументом в функции вывода становится указатель на корень списка, а сама функция последовательно обходит все элементы перечня с последующим их выводом (значений)."},
        {id: 94, text: "Обеспечение взаимообмена"},
        {id: 95, text: "При подобных обстоятельствах кодификация, используемая для реализации поставленной задачи будет иметь примерно следующее представление:"},
        {id: 96, code: "struct list * swap(struct list *lst1, struct list *lst2, struct list *head)"},
        {id: 97, code: "{"},
        {id: 98, code: "ㅤㅤ// Возвращение нового корня списка"},
        {id: 99, code: "ㅤㅤstruct list *prev1, *prev2, *next1, *next2;"},
        {id: 100, code: "ㅤㅤprev1 = head;"},
        {id: 101, code: "ㅤㅤprev2 = head;"},
        {id: 102, code: "ㅤㅤif (prev1 == lst1)"},
        {id: 103, code: "ㅤㅤㅤㅤprev1 = NULL;"},
        {id: 104, code: "ㅤㅤelse"},
        {id: 105, code: "ㅤㅤㅤㅤwhile (prev1->ptr != lst1) // ищется элемент, который предшествует lst1"},
        {id: 106, code: "ㅤㅤㅤㅤprev1 = prev1->ptr;"},
        {id: 107, code: "ㅤㅤif (prev2 == lst2)"},
        {id: 108, code: "ㅤㅤㅤㅤprev2 = NULL;"},
        {id: 109, code: "ㅤㅤelse"},
        {id: 110, code: "ㅤㅤㅤㅤwhile (prev2->ptr != lst2) // осуществляется поиск узла, идущего перед lst2"},
        {id: 111, code: "ㅤㅤㅤㅤㅤㅤprev2 = prev2->ptr;"},
        {id: 112, code: "ㅤㅤnext1 = lst1->ptr;  // «часть», идущая после lst1"},
        {id: 113, code: "ㅤㅤnext2 = lst2->ptr;  // узел после lst2"},
        {id: 114, code: "ㅤㅤif (lst2 == next1)"},
        {id: 115, code: "ㅤㅤ{  // непосредственный обмен данными соседних элементов"},
        {id: 116, code: "ㅤㅤㅤㅤlst2->ptr = lst1;"},
        {id: 117, code: "ㅤㅤㅤㅤlst1->ptr = next2;"},
        {id: 118, code: "ㅤㅤㅤㅤif (lst1 != head)"},
        {id: 119, code: "ㅤㅤㅤㅤㅤㅤprev1->ptr = lst2;"},
        {id: 120, code: "ㅤㅤ}"},
        {id: 121, code: "ㅤㅤelse"},
        {id: 122, code: "ㅤㅤㅤㅤif (lst1 == next2)"},
        {id: 123, code: "ㅤㅤㅤㅤ{"},
        {id: 124, code: "ㅤㅤㅤㅤㅤㅤ// обмен соседних узлов"},
        {id: 125, code: "ㅤㅤㅤㅤㅤㅤlst1->ptr = lst2;"},
        {id: 126, code: "ㅤㅤㅤㅤㅤㅤlst2->ptr = next1;"},
        {id: 127, code: "ㅤㅤㅤㅤㅤㅤif (lst2 != head)"},
        {id: 128, code: "ㅤㅤㅤㅤㅤㅤㅤㅤprev2->ptr = lst2;"},
        {id: 129, code: "ㅤㅤㅤㅤ}"},
        {id: 130, code: "ㅤㅤㅤㅤelse"},
        {id: 131, code: "ㅤㅤㅤㅤㅤㅤ// обмен отстоящий элементов"},
        {id: 132, code: "ㅤㅤㅤㅤㅤㅤif (lst1 != head)"},
        {id: 133, code: "ㅤㅤㅤㅤㅤㅤㅤㅤprev1->ptr = lst2;"},
        {id: 134, code: "ㅤㅤㅤㅤㅤㅤlst2->ptr = next1;"},
        {id: 135, code: "ㅤㅤㅤㅤㅤㅤif (lst2 != head)"},
        {id: 136, code: "ㅤㅤㅤㅤㅤㅤㅤㅤprev2->ptr = lst1;"},
        {id: 137, code: "ㅤㅤㅤㅤㅤㅤlst1->ptr = next2;"},
        {id: 139, code: "ㅤㅤ}"},
        {id: 140, code: "ㅤㅤif (lst1 == head)"},
        {id: 141, code: "ㅤㅤㅤㅤreturn(lst2);"},
        {id: 142, code: "ㅤㅤif (lst2 == head)"},
        {id: 143, code: "ㅤㅤㅤㅤreturn(lst1);"},
        {id: 144, code: "ㅤㅤreturn(head);"},
        {id: 145, code: "}"},
        {id: 146, text: "В этом случае работа связных списков основывается на обмене узлового характера. Аргументы функций ОЛС – это два указателя на обмениваемые узлы, а также указатели корня списка. Функция отвечает за возврат корневого «объекта» списка."},
        {id: 147, text: "Могут рассматриваться разные ситуации:"},
        {id: 148, text: "заменяемые «частицы» находятся по соседству;"},
        {id: 149, text: "обрабатываемые узлы – не соседние."},
        {id: 150, text: "Когда маркеры переустанавливаются, требуется проверка на причастность к корню списка. Если заменяемая составляющая является таковой, все нормально. В противном случае узел, предшествующий корневому, будет отсутствовать."},
        {id: 151, text: "Двусвязные"},
        {id: 152, text: "Еще один тип связных списков – двусвязный. Он похож на обычный, но составляющие хранят ссылки не только на следующие, но и на предыдущие «частицы». Это позволяет осуществлять перемещение по списку туда-сюда. Односвязный список, в отличие от предложенного вниманию, предусматривает только движение вперед."},
        {id: 153, text: "Каждый элемент в данном случае будет иметь несколько полей: next и prev, указатели на предыдущий/следующий составляющие соответственно."},
        {id: 154, text: "Далее будут рассмотрены основные операции с двусвязными «перечнями». Пусть они предусматривают несколько конструкторов (Null и DoublyList), в которых возможны различные действия."},
        {id: 155, text: "Для Null (изначально список пуст):"},
        {id: 156, text: "data – место хранения имеющихся значений;"},
        {id: 157, text: "next – указатель на следующую составляющую «перечня»;"},
        {id: 158, text: "previous – маркер предыдущего элемента."},
        {id: 159, text: "Для DoublyList:"},
        {id: 160, text: "tail – конец списка;"},
        {id: 161, text: "head – начало списка;"},
        {id: 162, text: "_lenght – извлечение количества узлов в «перечне»;"},
        {id: 163, text: "add(value) – добавление новой составляющей;"},
        {id: 164, text: "remove(position) – отвечает за удаление;"},
        {id: 165, text: "searchNodeAt(position) – поиск узла на заданной позиции."},
        {id: 166, text: "Коды будут выглядеть соответственно:"},
        {id: 167, code: "function Node(value) {"},
        {id: 168, code: "ㅤㅤthis.data = value;"},
        {id: 169, code: "ㅤㅤthis.previous = null;"},
        {id: 170, code: "ㅤㅤthis.next = null;"},
        {id: 171, text: "}"},
        {id: 172, text: "И public class Doubly:"},
        {id: 173, code: "funcntion DoublyList() {"},
        {id: 174, code: "ㅤㅤthis._length = 0;"},
        {id: 175, code: "ㅤㅤthis.head = null;"},
        {id: 176, code: "ㅤㅤthis,tail = null;"},
        {id: 177, text: "Метод добавления"},
        {id: 178, text: "Двунаправленные списки предусматривают метод добавления. Приведенный пример отвечает за реализацию нескольких сценариев.  Если перечень пуст, список по голове и хвосту получает добавляемый узел. Добавляется новый элемент. Когда «перечень» уже имеет «составляющие», нужно найти конец и установить добавляемый узел как tail.next."},
        {id: 179, code: "DoublyList.prototype.add = function(value) {"},
        {id: 180, code: "ㅤㅤvar node = new Node(value);"},
        {id: 181, code: "ㅤㅤif (this._length) {"},
        {id: 182, code: "ㅤㅤㅤㅤthis.tail.next = node;"},
        {id: 183, code: "ㅤㅤㅤㅤnode.previous = this.tail;"},
        {id: 184, code: "ㅤㅤㅤㅤthis.tail = node;"},
        {id: 185, code: "ㅤㅤ} else {"},
        {id: 186, code: "ㅤㅤㅤㅤthis.head = node;"},
        {id: 187, code: "ㅤㅤㅤㅤthis.tail = node;"},
        {id: 188, code: "ㅤㅤ}"},
        {id: 189, code: "ㅤㅤthis._length++;"},
        {id: 190, code: "ㅤㅤreturn node;"},
        {id: 191, code: "};"},
        {id: 192, text: "После этого задается двунаправленная обработка для нового окончания. Требуется установить в качестве tail.previous первоначальную конечную «составляющую»."},
        {id: 193, text: "Метод поиска"},
        {id: 194, text: "В данном случае действовать предстоит подобно ситуации с односвязными «перечнями»:"},
        {id: 195, code: "DoublyList.prototype.searchNodeAt = function(position) {"},
        {id: 196, code: "ㅤㅤvar currentNode = this.head,"},
        {id: 197, code: "ㅤㅤㅤㅤlength = this._length,"},
        {id: 198, code: "ㅤㅤㅤㅤcount = 1,"},
        {id: 199, code: "ㅤㅤㅤㅤmessage = {failure: 'Failute: non-existent node in this list.'};"},
        {id: 200, code: "ㅤㅤ//1-ый случай: неверная позиция"},
        {id: 201, code: "ㅤㅤif (length === 0 || position < 1 || position > length) {"},
        {id: 202, code: "ㅤㅤㅤㅤthrow new Error(message.failure);"},
        {id: 203, code: "ㅤㅤ}"},
        {id: 204, code: "ㅤㅤ//2-ый случай: верная позиция"},
        {id: 205, code: "ㅤㅤwhile (count < position) {"},
        {id: 206, code: "ㅤㅤㅤㅤcurrentNode = currentNode.next;"},
        {id: 207, code: "ㅤㅤㅤㅤcount++"},
        {id: 208, code: "ㅤㅤ}"},
        {id: 209, code: "ㅤㅤreturn currentNode;"},
        {id: 210, code: "};"},
        {id: 211, text: "Предложенный список будет обрабатываться для поиска элемента на заданной позиции."},
        {id: 212, text: "Стирание"},
        {id: 213, text: "Это более сложный код для пользовательского понимания. Поэтому сначала стоит рассмотреть его представление:"},
        {id: 214, text: "Здесь remove(position) будет обрабатывать несколько возможных ситуаций:"},
        {id: 215, code: "DoublyList.prototype.remove = function(position) {"},
        {id: 216, code: "ㅤㅤvar currentNode = this.head,"},
        {id: 217, code: "ㅤㅤㅤㅤlength = this._length,"},
        {id: 218, code: "ㅤㅤㅤㅤcount = 1,"},
        {id: 219, code: "ㅤㅤㅤㅤmessage = {failure: 'Failure: non-existent node in this list'}"},
        {id: 220, code: "ㅤㅤㅤㅤbeforeNodeToDelete = null,"},
        {id: 221, code: "ㅤㅤㅤㅤnodeToDelete = null,"},
        {id: 222, code: "ㅤㅤㅤㅤdeletedNode = null;"},
        {id: 223, code: "ㅤㅤ// 1-ый случай: неверная позиция"},
        {id: 224, code: "ㅤㅤif (length === 0 || position < 1 || position > length) {"},
        {id: 225, code: "ㅤㅤㅤㅤthrow new Error(message.failure);"},
        {id: 226, code: "ㅤㅤ}"},
        {id: 227, code: "ㅤㅤ//2-ой случай: первый узел удалён"},
        {id: 228, code: "ㅤㅤif (position === 1) {"},
        {id: 229, code: "ㅤㅤㅤㅤthis.head = currentNode.next;"},
        {id: 230, code: "ㅤㅤㅤㅤ// 2-ой случай: существует второй узёл"},
        {id: 231, code: "ㅤㅤㅤㅤif (!this.head) {"},
        {id: 232, code: "ㅤㅤㅤㅤㅤㅤthis.head.previous = null;"},
        {id: 233, code: "ㅤㅤㅤㅤ// 2-ой случай: второго узла не существует"},
        {id: 234, code: "ㅤㅤㅤㅤ} else {"},
        {id: 235, code: "ㅤㅤㅤㅤㅤㅤthis.tail = null;"},
        {id: 236, code: "ㅤㅤㅤㅤ}"},
        {id: 237, code: "ㅤㅤ// 3-ий случай: последний узел удалён"},
        {id: 238, code: "ㅤㅤ} else if (position === this.length) {"},
        {id: 239, code: "ㅤㅤㅤㅤthis.tail = this.tail.previous;"},
        {id: 240, code: "ㅤㅤㅤㅤthis.tail.next = null;"},
        {id: 241, code: "ㅤㅤ//4-ый случай: средний узел удалён"},
        {id: 242, code: "ㅤㅤ} else {"},
        {id: 243, code: "ㅤㅤㅤㅤwhile (count < position) {"},
        {id: 244, code: "ㅤㅤㅤㅤㅤㅤcurrentNode = currentNode.next;"},
        {id: 245, code: "ㅤㅤㅤㅤㅤㅤcount++;"},
        {id: 246, code: "ㅤㅤㅤㅤ}"},
        {id: 247, code: "ㅤㅤㅤㅤbeforeNodeToDelete = currentNode.previous;"},
        {id: 248, code: "ㅤㅤㅤㅤnodeToDelete = currentNode;"},
        {id: 249, code: "ㅤㅤㅤㅤafterNodeToDelete = currentNode.next;"},
        {id: 250, code: "ㅤㅤㅤㅤbedoreNodeToDelete.previous = beforeNodeToDelete;"},
        {id: 251, code: "ㅤㅤㅤㅤdeleteNode = nodeDelete;"},
        {id: 252, code: "ㅤㅤㅤㅤnodeToDelete = null;"},
        {id: 253, text: "ㅤㅤ}"},
        {id: 254, code: "ㅤㅤthis._length--;"},
        {id: 255, code: "ㅤㅤreturn message.succes;"},
        {id: 256, code: "};"},
        {id: 257, text: "Позиции, которая передается в качестве аргумента remove не имеет места. На экран будет выводиться сообщение об ошибке."},
        {id: 258, text: "Позиция, служащая аргументом remove – это первый узел списка (голова). В случае подтверждения соответствующего утверждения head становится deleteNode, после чего в качестве нового начала назначается следующий узел в «перечне». Дальше осуществляется проверка на наличие большего количества «составляющих». Если они отсутствуют, head получает null, происходит переход к части if в операторе if-else. В теле «ифа» устанавливается конец (tail) в виде null. Происходит возврат списка в исходное «положение» пустого двусвязного «перечня». Когда удаляется первый узел и остается более одного элемента, осуществляется перемещение к else, после чего устанавливается свойство previous для головы на null. Это проделывается, так как перед началом других «объектов» больше нет."},
        {id: 259, text: "Позиция-аргумент remove – это окончание «перечня». Хвосту присваивается deleteNode, в качестве нового окончания выступает предыдущий узел. После нового tail другие узлы отсутствуют, а он получает свойство next как null."},
        {id: 260, text: "Цикл while разрывается, стоит лишь currentNide указать на элемент, который находится в позиции-аргументе remove. Далее происходит переназначение beforeNodeToDelete и afterToDelete на «объект», который идет после nodeToDelete и перед ним. Ссылки убираются на удаленный узел, переназначаются на правильные. Завершается операция установкой nodeToDelete в значении deletedNode, а значением служит null."},
        {id: 261, text: "В результате описанного алгоритма происходит уменьшение длины списка с последующим возвратом deletedNode."},
        {id: 262, text: "Теперь понятно, каким может быть первый элемент односвязного списка или двусвязного, как он называется и используется на практике. Приведенные примеры помогают лучше ориентироваться в изученной теме. Они не являются исчерпывающими."},
        {id: 263, text: "Односвязный список — элементарный, без «пути назад». В программах чаще всего используются их двусвязные аналоги, предоставляющие большее поле для различных манипуляций."}
    ],
    functionsLinkedPage: [
        {id: 1, themeName: "Функции"},
        {id: 2, text: "А вот программа в 100+ строк — уже большая, и разбираться в ее коде довольно сложно. Можно ли как-то упростить написание и чтение программ с большим количеством кода?"},
        {id: 3, text: "Да, и помогут нам в этом методы (функции)."},
        {id: 4, text: "Что же такое метод? Ну, если очень сильно упростить, то метод — это группа команд, у которой есть уникальное имя. Другими словами, мы просто компонуем несколько команд в одну группу и даем ей уникальное имя. И все — метод готов."},
        {id: 5, text: "Без метода"},
        {id: 6, code: "class Solution{"},
        {id: 7, code: "ㅤㅤpublic static void main(String[] args){"},
        {id: 8, code: 'ㅤㅤㅤㅤSystem.out.print("Wi-");'},
        {id: 9, code: 'ㅤㅤㅤㅤSystem.out.println("Fi");'},
        {id: 10, code: 'ㅤㅤㅤㅤSystem.out.print("Wi-");'},
        {id: 11, code: 'ㅤㅤㅤㅤSystem.out.println("Fi");'},
        {id: 12, code: 'ㅤㅤㅤㅤSystem.out.print("Wi-");'},
        {id: 13, code: 'ㅤㅤㅤㅤSystem.out.println("Fi");'},
        {id: 14, code: "ㅤㅤ}"},
        {id: 15, code: "}"},
        {id: 16, text: "С методом"},
        {id: 17, code: "class Solution{"},
        {id: 18, code: "ㅤㅤpublic static void main(String[] args){"},
        {id: 19, code: "ㅤㅤㅤㅤprintWiFi();"},
        {id: 20, code: "ㅤㅤㅤㅤprintWiFi();"},
        {id: 21, code: "ㅤㅤㅤㅤprintWiFi();"},
        {id: 22, code: "}"},
        {id: 23, code: "ㅤㅤpublic static void printWiFi(){"},
        {id: 24, code: 'ㅤㅤㅤㅤSystem.out.print("Wi-");'},
        {id: 25, code: 'ㅤㅤㅤㅤSystem.out.print("Wi-");'},
        {id: 26, code: "ㅤㅤ}"},
        {id: 27, code: "}"},
        {id: 28, text: "В программе в верхней колонке у нас три раза повторяется один и тот же код — мы так специально сделали для примера. А в программе снизу мы вынесли повторяющийся код в отдельный метод и дали ему уникальное имя — printWiFi."},
        {id: 29, text: "И вместо вынесенного кода 3 раза написали вызов метода printWiFi()."},
        {id: 30, text: "Когда программа в колонке снизу будет исполняться, каждый раз при выполнении команды printWiFi() она будет выполнять все команды внутри метода printWiFi(). Мы просто создали новую команду (метод), объединив в одну группу несколько команд."},
        {id: 31, text: "Любой код можно разбить на отдельные методы. Это делают для упрощения: считается, что лучше иметь много маленьких методов, чем один большой.  Скоро вы будете удивляться тому, что раньше писали свои программы, но не писали свои методы."},
        {id: 32, text: "Объявление метода в Java"},
        {id: 33, text: "Так как все-таки правильно написать свой метод?"},
        {id: 34, text: "При объявлении (создании) метода нужно учитывать много нюансов, но давайте начнем с основного. Как нам все-таки объявить самый простой метод? Объявление простого метода выглядит так:"},
        {id: 35, code: "public static void имя(){"},
        {id: 36, code: "ㅤㅤкод метода"},
        {id: 37, code: "}"},
        {id: 38, text: "Где имя — это уникальное имя метода, а код метода — это команды, из которых состоит метод. Значение слов public, static и void мы рассмотрим несколько позднее."},
        {id: 39, text: "После того, как мы создали метод, мы можем вызывать его в других наших методах. Вызов выглядит так:"},
        {id: 40, code: "имя();"},
        {id: 41, text: "Где имя — это уникальное имя метода, который мы хотим вызвать, и команды которого мы хотим выполнить в месте его вызова."},
        {id: 42, text: "Когда программа дойдет до команды, содержащей вызов нашего метода, она просто перейдет в метод, выполнит все его команды, вернется в изначальный метод и продолжит выполнение."},
        {id: 43, text: "Как вы уже, наверное, догадались, большая часть изученных нами ранее команд — это просто методы, написанные другими программистами, чтобы облегчить нам жизнь: System.out.println(), Thread.sleep(), и т.д."},
        {id: 44, text: "Факты о методах"},
        {id: 45, text: "Факт 1. Метод — это всегда часть класса."},
        {id: 46, text: "Метод можно объявить только в классе.  Метод нельзя объявить внутри другого метода. Метод нельзя объявить вовне класса."},
        {id: 47, text: "Факт 2. Имя метода не несет сакрального смысла"},
        {id: 48, text: "Неважно, как называются методы — это ни на что не влияет. Метод main — это такой же метод, как и все остальные. Просто такое имя выбрали для метода, с которого Java-машина начинает исполнение программы. Ничего волшебного в нем нет."},
        {id: 49, text: "Факт 3. Порядок методов в классе не важен"},
        {id: 50, text: "Вы можете написать ваши методы в классе в любом порядке — это никак не повлияет на выполнение программы."},
        {id: 51, text: "Факт 4. Переменные внутри одного метода никак не связаны с переменными других методов"},
        {id: 52, text: "Переменные, объявленные внутри метода, остаются внутри этого метода."},
        {id: 53, text: "В двух соседних методах могут быть объявлены одинаковые переменные, и эти переменные никак не связаны друг с другом."},
        {id: 54, text: "Имена методов"},
        {id: 55, text: "Уже давно известно, что в программировании две самые сложные проблемы — как правильно подобрать название метода и как назвать переменную."},
        {id: 56, text: "На самом деле, уже существует чуть ли не целая наука о том, как правильно называть методы. И у каждого языка программирования есть свои стандарты. В Java принято руководствоваться такими принципами:"},
        {id: 57, text: "Принцип 1. Имя метода должно кратко описывать то, что этот метод делает."},
        {id: 58, text: "Тогда программист, который читает ваш код, по имени метода сможет догадаться, что этот код делает, и ему не нужно будет каждый раз смотреть код вызываемых методов. Да и назначение методов запомнить легче."},
        {id: 59, text: "Вспомните тот же Thread.sleep() — «усыпить программу» и Scanner.nextInt() — «считать следующее целое число». Удобно же, правда."},
        {id: 60, text: "Принцип 2. Имя метода может состоять из нескольких слов."},
        {id: 61, text: "Однако для этого случая есть несколько ограничений:"},
        {id: 62, text: "Пробелы в имени метода писать нельзя: все слова пишутся слитно."},
        {id: 63, text: "Каждое слово пишется с большой буквы, кроме первого."},
        {id: 64, text: "Имя метода всегда пишется с маленькой буквы"},
        {id: 65, text: "Вспомните тот же метод printWiFi10Times. Что значит его имя? «написать 10 раз слово WiFi». Много слов в имени метода писать не нужно: имя должно отражать самую суть."},
        {id: 66, text: "Такой стандарт написания имен называется CamelCase (Camel — верблюд. Большие буквы похожи на верблюжьи горбы)."},
        {id: 67, text: "Принцип 3. Имя метода начинается с глагола."},
        {id: 68, text: "Метод всегда что-то делает, поэтому первое слово в названии метода — это всегда действие."},
        {id: 69, text: "Плохие имена для метода: home, cat, car, train, ...;"},
        {id: 70, text: "Хорошие имена: run, execute, print, read, write, ..."},
        {id: 71, text: "Принцип 4.  Используйте только латинские буквы и цифры"},
        {id: 72, text: "Java очень хорошо поддерживает разные языки. Вы можете написать имена переменных, методов и классов хоть на русском, хоть на китайском — все будет работать!"},
        {id: 73, text: "Но! Как долго вы бы учили Java, если бы названия метода System.out.println() было на китайском? Гораздо дольше, чем сейчас, не так ли? Это, во-первых."},
        {id: 74, text: "Во-вторых, над многими проектами работают интернациональные команды. Очень большое количество Java-библиотек используется программистами со всего мира."},
        {id: 75, text: "Поэтому рекомендуется в именах методов использовать только латинские буквы и цифры."},
        {id: 76, text: "Важно:"},
        {id: 77, text: "Имя метода обязательно должно начинаться с буквы (с цифры — нельзя)."}
    ]
}


export default state;