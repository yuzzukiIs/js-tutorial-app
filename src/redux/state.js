let state = {
    greetingPage: [
        {text: "Путеводитель по JavaScript"}
    ],
    catalogPage: [
        {id: 1, theme: "Введение в JavaScript", link:"/introduction"},
        {id: 2, theme: "Переменные", link:"/variables"},
        {id: 3, theme: "Типы данных", link:"/dataTypes"},
        {id: 4, theme: "Выражения и операторы", link:"/expressions&operators"},
        {id: 5, theme: "Условия", link:"/conditions"},
        {id: 6, theme: "Структурированные данные", link:"/structuredData"},
        {id: 7, theme: "Циклы", link:"/cycles"},
        {id: 8, theme: "Функции", link:"/functions"}
    ],
    introductionPage: [
        {id: 1, themeName: "Введение в JavaScript"},
        {id: 2, text: "JavaScript, часто сокращенно JS, — это язык программирования, который является одной из основных технологий Всемирной паутины, наряду с HTML и CSS. Это позволяет нам добавлять интерактивность на страницы, например. Вы могли видеть ползунки, оповещения, клики, всплывающие окна и т. д. на разных веб-сайтах — все это построено с использованием JavaScript. Помимо использования в браузере, он также используется в других небраузерных средах, таких как Node.js для написания кода на стороне сервера в JavaScript, Electron для написания настольных приложений, React Native для мобильных приложений и так далее."},
        {id: 3, text: "Первоначально JavaScript был создан Бренданом Эйхом из NetScape и впервые был анонсирован в пресс-релизе Netscape в 1995 году. У него причудливая история именования; Первоначально создатель назвал его Mocha, который позже был переименован в LiveScript. В 1996 году, примерно через год после выпуска, NetScape решила переименовать его в JavaScript в надежде извлечь выгоду из сообщества Java (хотя JavaScript не имел никакого отношения к Java) и выпустила Netscape 2.0 с официальной поддержкой JavaScript."},
        {id: 4, text: "JavaScript как правило можно запустить в браузере написав скрипты в отдельном файле с расширением “.js”(например index.js) и подключив его к html файлу. Но браузеры не единственные места где используется JavaScript. Например JavaScript можно запускать совместно с библиотеками и фреймворками. Также есть серверный JS(Node.js). Ознакомиться со способами применения JS можно через YouTube, там уже полно контента на эту тему."},
        {id: 5, text: "Как работает JavaScript"},
        {id: 6, text: "Парсер идентифицирует, анализирует и классифицирует различные части программы. Например, устанавливает, является ли элемент функцией, переменной и т.д. с помощью ключевых слов JavaScript."},
        {id: 7, text: "Затем AST (абстрактные синтаксические деревья) создают древовидную структуру на основе классификации парсера. В AST Explorer можно узнать о том, как строится дерево."},
        {id: 8, text: "Затем дерево передается интерпретатору, который создает байт-код. Как мы узнали ранее, байт-код не является кодом самого низкого уровня, однако его можно интерпретировать. На этой стадии браузер работает с доступным байт-кодом с помощью движка V8, чтобы пользователю не приходилось ждать."},
        {id: 9, text: "В то же время профайлер ищет оптимизации кода, а затем передает входные данные компилятору. Компилятор выдает оптимизированный код, в то время как байт-код временно используется для рендеринга в браузере. Как только компилятор создает оптимизированный код, временный байт-код полностью заменяется новым оптимизированным кодом."},
        {id: 10, text: "Таким образом используются лучшие качества интерпретатора и компилятора. Интерпретатор выполняет код, в то время как профайлер ищет оптимизацию, а компилятор создает оптимизированный код. Затем байт-код заменяется оптимизированным кодом, который является кодом более низкого уровня, таким как машинный код."},
        {id: 11, text: "Это означает, что производительность будет постепенно улучшаться, не блокируя время выполнения."}
    ],  
    variablesPage: [
        {id: 1, themeName: "Переменные"},
        {id: 2, text: "Переменные – это «именованные хранилища» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных."},
        {id: 3, link: "виды объявлений переменных"},
        {id: 4, text: "Говоря о var. Var это способ объявления переменной по старому стандарту EcmaScript. В современной разработке уже используют let и const."},
        {id: 5, link: "в JavaScript существуют константы"},
        {id: 6, text: "Важно! В JavaScript есть зарезервированные слова. Зарезервированные слова в JavaScript — это слова, которые пока еще не существуют в ядре языка JavaScript и не встроены в его синтаксис, но в будущем, эти слова могут быть внедрены в ядро JavaScript. В качестве имён идентификаторов (переменных, функций, объектов, массивов и т."},
        {id: 7, link: "список зарезервированных слов"},
        {id: 8, text: "Также важно не именовать конструкции языка именами встроенных методов языка. То есть, если вы напишете let console; или const var = значение; то непременно выйдет ошибка при интерпритации языка."},
        {id: 9, title: "Области видимости переменных"},
        {id: 10, text: "Область видимости — важная концепция, определяющая доступность переменных. Данная концепция лежит в основе замыканий, разделяя переменные на глобальные и локальные."},
        {id: 11, link: "области видимости переменных"}
    ],
    dataTypesPage: [
        {id: 1, themeName: "Типы данных"},
        {id: 2, title: "В JavaScript есть 8 типов данных:"},
        {id: 3, text: "number - числовые значения"},
        {id: 4, text: "bigInt - очень большие целочисленные значения"},
        {id: 5, text: "boolean - логические выражения true и false"},
        {id: 6, text: "string - строковые значения"},
        {id: 7, text: "symbol - уникальное значение, которое часто применяется для обращения к свойствам сложных объектов"},
        {id: 8, text: "null - намеренное отсутсвие значения"},
        {id: 9, text: "undefined - ненамеренно неустановленное значение"},
        {id: 10, text: "object - сложный, комплексный тип данных, который состоит из значений примитивных типов или других объектов"},
        {id: 11, link: "о типах данных"},
        {id: 12, title: "Преобразование типов"},
        {id: 13, text: "Преобразование типов (или приведение типов) означает перенос данных из одного типа данных в другой. Неявное преобразование происходит, когда компилятор (для скомпилированных языков) или среда выполнения (для скриптовых языков, таких как JavaScript) автоматически преобразует типы данных. Исходный код также может явно требовать преобразования."}
    ],
    expressionsAndOperatorsPage: [
        {id: 1, themeName: "Выражения и операторы"},
        {id: 2, title: "Операторы присваивания"},
        {id: 3, text: "В результате операции присваивания операнду(операнд это объект или проще говоря цель над которым вы проводите действия, например присваивание значения или же к примеру, сложение) слева устанавливается значение , которое берётся из правого операнда. Основным оператором присваивания является =, он присваивает значение правого операнда операнду, находящемуся слева. Таким образом, выражение x = y означает, что x имеет значение равное y."},
        {id: 4, title: "Арифметические операции"},
        {id: 5, text: "Арифметические операторы используют в качестве своих операндов числа (а также переменные и константы) и в качестве результата возвращают одно числовое значение. Стандартными арифметическими операторами являются сложение (+), вычитание (-), умножение (*), и деление (/). При работе с числами с плавающей точкой эти операторы работают аналогично их работе в большинстве других языках программирования (обратите внимание, что деление на ноль возвращает бесконечность Infinity)."},
        {id: 6, title: "Битовые(поразрядные) операции"},
        {id: 7, text: "Битовые операторы обрабатывают свои операнды как последовательности из 32 бит (нулей и единиц), а не как десятичные, шестнадцатеричные или восьмеричные числа. Например, десятичное число 9 имеет двоичное представление 1001. Битовые операторы выполняют операции над таким двоичным представлением, но результат возвращают как обычное числовое значение JavaScript."},
        {id: 8, link: "битовые операторы"},
        {id: 9, title: "Логические операторы"},
        {id: 10, text: "Логические операторы обычно используются с булевыми (true - 1, false - 0) значениями; при этом возвращаемое ими значение также является булевым. Однако операторы && и || фактически возвращают значение одного из операндов, поэтому, если эти операторы используются с небулевыми величинами, то возвращаемая ими величина также может быть не булевой. "},
        {id: 12, link: "логические операторы"},
        {id: 13, title: "Строковые операторы"},
        {id: 14, text: "В дополнение к операторам сравнения, которые могут использоваться со строковыми значениями, оператор (+) позволяет объединить две строки, возвращая при этом третью строку, которая представляет собой объединение двух строк-операндов"},
        {id: 15, title: "Тернарный оператор"},
        {id: 16, text: "Тернарный оператор является единственным оператором JavaScript, который использует три операнда. Оператор принимает одно из двух значений в зависимости от заданного условия. "},
        {id: 17, link: "тернарный оператор"},
        {id: 18, title: "Унарный оператор"},
        {id: 19, text: "Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус - меняет знак числа на противоположный."},
        {id: 20, title: "Инкремент и декремент"},
        {id: 21, text: "Инкремент - операция увеличения операнда на 1, а декремент это операция в обратную сторону. Допустим есть переменная apples = 5; Применив инкремент(apples++) получим apples = 6;"},
        {id: 22, title: "Приоритеты операторов:"},
        {id: 23, externalLink: "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence"}
    ],
    conditionsPage: [
        {id: 1, themeName: "Условия"},
        {id: 2, title: "Условные операторы"},
        {id: 3, text: "Условные операторы позволяют проверить некотоое условие и в зависимости от результата выполнить действия."},
        {id: 4, text: "Допустим вы заказали пиццу, вас уже её доставили. Вы сидите с друзьями и вам надо поделить пиццу поровну между собой либо заказать ещё одну пиццу. Всё зависит от количества людей. Например, если в комнате только 2 человека, то вам обеим достаётся по половине пиццы, если же вас 4, то вам достаётся по одной четвёртой куска этой пиццы.  Если вас ещё больше, вы заказываете ещё одну пиццу."},
        {id: 5, link: "операторы if, else if, else"},
        {id: 6, title: "Оператор switch"},
        {id: 7, text: "Оператор switch определяет, отвечает ли выражение тем или иным условиям, и выполняет код, если это так. Сначала этот оператор кажется очень запутанным и сложным, но основной его синтаксис аналогичен синтаксису оператора if. Он всегда записывается как switch () {}. В круглых скобках находится выражение, которое нужно оценить, а в фигурных скобках содержится код для выполнения."},
        {id: 8, link: "оператор switch"}
    ],
    structuredDatasPage: [
        {id: 1, themeName: "Структурированные данные"},
        {id: 2, text: "В JavaScript разработчики часто тратят много времени на решение того, какую структуру данных следует использовать. Это вызвано тем, что выбор правильной структуры данных упрощает последующее управление этими данными, экономя время и упрощая понимание кода. Двумя преобладающими структурами для хранения коллекций данных являются объекты и массивы (тип объекта). Разработчики используют объекты для хранения пары ключ/значение и массивы для хранения индексированных списков. Однако, чтобы предоставить разработчикам больше гибкости, в спецификации ECMAScript 2015 появились два новых типа итерируемых объектов: карты (map), которые являются упорядоченными коллекциями пар ключ/значение, и сеты (set), которые содержат список уникальных значений."},
        {id: 3, title: "Массивы"},
        {id: 4, text: "И первая структура данных, которую нам надо рассмотреть это - массивы. Массивы представляют собой упорядоченный список данных, которыми можно управлять разнообразными способами."},
        {id: 5, link: "массивы"},
        {id: 6, title: "Объекты"},
        {id: 7, text: "JavaScript спроектирован на основе простой парадигмы. В основе концепции лежат простые объекты. Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Значением свойства может быть функция, которую можно назвать методом объекта."},
        {id: 8, link: "объекты"},
        {id: 9, title: "Сеты"},
        {id: 10, text: "Объекты Set представляют коллекции значений, по которым вы можете выполнить обход в порядке вставки элементов. Значение элемента в Set может присутствовать только в одном экземпляре, что обеспечивает его уникальность в коллекции Set."},
        {id: 11, link: "сеты"},
        {id: 12, title: "Мапы"},
        {id: 13, text: "Map — это коллекция пар ключ/значение, которая может использовать любой тип данных в качестве ключа и поддерживает порядок своих записей. Карты содержат как характеристики объектов (коллекция пар ключ/значение), так и массивов (упорядоченная коллекция), но имеют больше сходства с объектами. Это связано с тем, что хотя размер и порядок записей сохраняется, как и в массиве, сами по себе записи являются парами ключ/значение, как объекты."},
        {id: 14, link: "мапы"}
    ],
    cyclesPage: [
        {id: 1, themeName: "Циклы"},
        {id: 2, text: "Цикл - это блок кода, который способен выполнять однообразные действия до правильно указанной границы, цикл может быть бесконечным, но лучше этого не допускать."},
        {id: 3, code: "const arr = [0, -42, 1, 0, 45];"},
        {id: 4, code: "ㅤlet num = arr[0];"},
        {id: 5, code: "for(let i = 0; i < arr.length; i++){"},
        {id: 6, code: "ㅤㅤif(arr[i] > num){"},
        {id: 7, code: "ㅤㅤㅤnum = arr[i];"},
        {id: 8, code: "ㅤ}"},
        {id: 9, code: "}"},
        {id: 10, code: "while(num < 45)"},
        {id: 11, code: "ㅤㅤconsole.log(‘not maximal number’);"},
        {id: 12, code: "}"},
        {id: 13, code: "do{"},
        {id: 14, code: "ㅤㅤconsole.log(‘equal to 0’);"},
        {id: 15, code: "} while(num === 0);"},
        {id: 16, text: "Приведены три вида циклов(for, while, do while), но помните, что есть ещё методы массивов, которые могут работать подобно циклам."}
    ],
    functionsPage: [
        {id: 1, themeName: "Функции"},
        {id: 2, text: "Функция - конструкция программы, которая выполняет код внутри своего тела и вызывается её объявлением как в другой части кода или внутри неё самой. Для работы функции нужно передать ей значения в виде её аргументов. Что примечательно, количественного ограничения для принимаемых значений функции нет, зависит от того сколько аргументов функция использует. Получив аргументы через вызов, функция выполняет инструкции внутри себя и возвращает конечный результат, в противном случае в JS функция возвращает значение “undefined”."},
        {id: 3, link: "примеры функций"}
    ],
    variablesLinkedPage: [
        {id: 1, themeName: "Виды объявлений переменных"},
        {id: 2, code: "let variable1;"},
        {id: 3, code: "var variable2;"},
        {id: 4, text: "Поскольку JS является языком программирования высокого уровня, а также динамически типизированным языком, то синтаксис позволяет присваивать значения переменной не сразу после объявления, а также ошибок не возникает из-за того, что вы явно не объявите тип хранимых данных у переменной."},
        {id: 5, code: "let applesAmount = 10;"},
        {id: 6, code: "var orangesAmount = 20;"},
        {id: 7, code: "orangesAmount =  3;"},
        {id: 8, code: "let fruitsSum = applesAmount + orangesAmount;"},
        {id: 9, code: "console.log(fruitsSum); //ответ = 13;"},
        {id: 10, text: "Создание переменных происходит после написания ключевого слова let или var, но var уже как правило не применяют, так как с течением времени стандарты написания кода в языке меняются. Var имеет глобальную область видимости, что может вызывать довольно неприятные последствия, в отличие от let. Об областях видимостей можете почитать в следующий разделах."},
        {id: 11, text: "И вот после объявления ключевого слова идёт название переменной “applesAmount” и присваивается значение 10 с помощью оператора “=”."},
        {id: 12, text: "И как вы поняли можно создавать переменные имеющий значения других переменных, или результату их операций. Так и сами переменные можно переназначать, отсюда и их название."},
        {id: 13, text: "Говоря о console.log(). Это встроенный метод языка JS, который выводит данные в консоли браузера. О том как открывать инстурменты разработчика в браузере и открывать консоль можно найти в Google и YouTube."}
    ],
    constantsLinkedPage: [
        {id: 1, themeName: "Константы"},
        {id: 2, code: "const userId ="},
        {id: 3, code: "dc5c7986daef50c1e02ab09b442ee34f;"},
        {id: 4, text: "Само понятие константа уже наверное вам знакомо уже со школы. Роль константы уже наверное вам ясна, и в отличие от переменной, константе нельзя переназначать хранимые данные после присвоения данных после создания константы."},
        {id: 5, code: "userId = 0; //ошибка поскольку константу"},
        {id: 6, code: "переназначать запрещено"},
        {id: 7, code: "const someFunction = (arg1, arg2) => {"},
        {id: 8, code: "..."},
        {id: 9, code: "}"},
        {id: 10, text: "Здесь представлен пример применения константы в создании стрелочной функции “someFunction”.  Важно, чтобы функция всегда выполняла только те действия, которые ей предназначены и не изменялась за свои “рамки” с течением времени. Ей нужно выполнять только то, что ей положено, поэтому и при её объявлении используется ключевое слово “const”."}
    ],
    visibilityAreaLinkedPage: [
        {id: 1, themeName: "Области видимости переменных"},
        {id: 2, code: "const message = 'Hello';"},
        {id: 3, code: "console.log(message) // 'Hello'"},
        {id: 4, text: "Создаётся глобальная переменная, значение которой можно достать из любой дальнейшей точки программы."},
        {id: 5, code: "if (true){"},
        {id: 6, code: "ㅤㅤconst message = 'Hello' "},
        {id: 7, code: "}"},
        {id: 9, code: "console.log(message) // ReferenceError:"},
        {id: 10, code: "message is not defined"},
        {id: 11, text: "В примере выше уже не получится обратиться к переменной “message” вне области видимости создаваемой конструкцией “if”. Создавая блок с условным оператором “if” вы автоматически создаёте область видимости блока “if”. Таким образом переменная обретает только локальное действие. Однако это не касается var, который не подчиняется данным правилам. Ибо “var” не имеет блочной области видимости."},
        {id: 12, code: "if (true){ // область видимости блока if"},
        {id: 13, code: "var count = 10"},
        {id: 14, code: "console.log(count) // 10 "},
        {id: 15, code: "}"},
        {id: 16, code: "console.log(count) // 10"},
        {id: 17, code: "{"},
        {id: 18, code: "ㅤㅤconst message = 'Hi'"},
        {id: 19, code: "ㅤㅤconsole.log(message) // 'Hi'"},
        {id: 20, code: "}"},
        {id: 21, code: "console.log(message)"},
        {id: 22, text: "Первый вызов “console.log(message)” сработает без проблем, поскольку этот метод вызывает константу в её же области видимости, а второй вызов не будет выполнен, так как он уже за гранью области видимости константы."},
        {id: 23, text: "Такие же правила действуют и для функций и для экспортируемых модулей языка. Таким образом, можно сказать, что область видимости — это механизм инкапсуляции для блоков кода, функций и модулей."},
        {id: 24, text: "Инкапсуляция(изоляция чего либо от внешнего, чтобы элементы внутри блока не взаимодействовали с элементами вне блока)"},
        {id: 25, text: "Области видимости могут быть вложенными."},
        {id: 26, code: "if(apples > 10){"},
        {id: 27, code: "ㅤㅤlet preResult = “need to count!”"},
        {id: 28, code: "ㅤㅤconsole.log(preResult);"},
        {id: 29, code: "ㅤㅤif(apples > 20){"},
        {id: 30, code: "ㅤㅤㅤㅤlet answer = “to much apples!”;"},
        {id: 31, code: "ㅤㅤㅤㅤconsole.log(answer);"},
        {id: 32, code: "ㅤㅤ}"},
        {id: 33, code: "}"},
        {id: 34, text: "Есть два вложенных блока условных операторов. У них у обеих свои области видимости и вызовы будут работать также только в пределах своих областей видимостей."}
    ],
    dataTypesLinkedPage: [
        {id: 1, themeName: "Типы данных JavaScript"},
        {id: 2, text: "JavaScript является слабо типизированным или динамическим языком. Это значит, что вам не нужно определять тип переменной заранее. Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов:"},
        {id: 3, text: "Number - в соответствии со стандартом ECMAScript, существует только один числовой тип, который представляет собой 64-битное число двойной точности согласно стандарту IEEE754. Другими словами, специального типа для целых чисел в JavaScript нет. Это означает, что при числовых операциях вы можете получить неточное (округлённое) значение. В дополнение к возможности представлять числа с плавающей запятой, есть несколько символических значений: +Infinity (положительная бесконечность), -Infinity (отрицательная бесконечность), и NaN (не число)."},
        {id: 4, text: "BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины. Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала или вызвать функцию BigInt, которая создаст число типа BigInt из переданного аргумента. Аргументом может быть число, строка и др."},
        {id: 5, code: "const bigint = 1234567890167890127890n;"},
        {id: 6, code: `const sameBigint = BigInt("1124567890");`},
        {id: 7, code: "const bigintFromNumber = BigInt(10); //"},
        {id: 8, code: "то же самое, что и 10n"},
        {id: 9, text: "Логическое (или булевое) значение - это примитивный тип данных, который может содержать в себе true или false (истина или ложь). JavaScript использует приведение типа, чтобы привести значение к true или false. Есть явные и скрытые методы преобразования значений в их логические аналоги."},
        {id: 10, code: "Boolean(false); // false"},
        {id: 11, code: "Boolean(undefined); // false"},
        {id: 12, code: "Boolean(null); // false"},
        {id: 13, code: "Boolean(''); // false"},
        {id: 14, code: "Boolean(NaN); // false"},
        {id: 15, code: "Boolean(0); // false"},
        {id: 16, code: "Boolean(-0); // false"},
        {id: 17, code: "Boolean(0n); // false"},
        {id: 18, code: "Boolean(true); // true"},
        {id: 19, code: "Boolean('hi'); // true"},
        {id: 20, code: "Boolean(1); // true"},
        {id: 21, code: "Boolean([]); // true"},
        {id: 22, code: "Boolean([0]); // true"},
        {id: 23, code: "Boolean([1]); // true"},
        {id: 24, code: "Boolean({}); // true"},
        {id: 25, code: "Boolean({ a: 1 }); // true"},
        {id: 26, text: "Получение булевого типа при использовании оператора “!”."},
        {id: 27, code: "const value = 'Строчка истины' "},
        {id: 28, code: "!!value // true"},
        {id: 29, text: "String - строка. Любой одиночный символ в кавычках — это строка. Пустая строка '' — это тоже строка. То есть строкой мы считаем все, что находится внутри кавычек, даже если это пробел, один символ или вообще отсутствие символов."},
        {id: 30, code: "let string1 = 'Hello';"},
        {id: 31, code: "let string2 = 'Goodbye';"},
        {id: 32, code: "let string3 = 'G';"},
        {id: 33, code: "let string4 = ' ';"},
        {id: 34, code: "let string5 = '';"},
        {id: 35, text: "Symbol - символ. «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol():"},
        {id: 36, code: `let id = Symbol("id");`},
        {id: 37, code: "let user = {"},
        {id: 38, code: `ㅤㅤname: "Вася",`},
        {id: 39, code: `ㅤㅤ[id]: 123 // просто "id: 123" не `},
        {id: 40, code: "сработает"},
        {id: 41, code: "};"},
        {id: 42, text: "Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет."},
        {id: 43, code: `let id1 = Symbol("id");`},
        {id: 44, code: `let id2 = Symbol("id");`},
        {id: 45, code: "alert(id1 == id2); // false"},
        {id: 46, text: "Null - намеренное отсутствие значения. В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно». В приведённом ниже коде указано, что значение переменной age неизвестно."},
        {id: 47, code: "let age = null;"},
        {id: 48, text: "Undefined - ненамеренное отсутсвие значения. Допустим объявлена переменная, но ей не присвоено никакого значения и мы её вызываем. Её значением будет undefined."},
        {id: 49, code: "let age;"},
        {id: 50, code: "console.log(age);"},
        {id: 51, text: "Object. Объекты используются для хранения коллекций различных значений и более сложных сущностей. В JavaScript объекты используются очень часто, это одна из основ языка. "},
        {id: 52, text: "Объекты имеют конструкцию из ключей и значений. В парадигме ООП(Объектно-ориентированное программирование) очень часто используется термин “сущность”, “атрибуты сущности”, ну а также “методы сущности”(под методами подразумеваются функции которые хранит объект(сущность))."},
        {id: 53, code: "let user1 = {"},
        {id: 54, code: `ㅤㅤname: "John",`},
        {id: 55, code: "ㅤㅤage: 20"},
        {id: 56, code: "};"},
        {id: 57, code: "let user2 = new Object();"},
        {id: 58, code: "let user3 = {...};"},
        {id: 59, text: "Выше приведены 3 примера создания объекта. Первый пример обладает ключами “name”, “age” и их значениями “John”, 20. Поскольку 20 числовой тип значения, он не требует каких либо кавычек. Во втором примере объект создаётся конструктором “new”. И наконец третий пример - это объявление литеральной нотацией."}
    ],
    bitOperationsLinkedPage: [
        {id: 1, themeName: "Битовые операции"},
        {id: 2, code: "a = 0;//00000000000000000000000000000000"},
        {id: 3, code: "a = 1;//00000000000000000000000000000001"},
        {id: 4, code: "a = 2;//00000000000000000000000000000010"},
        {id: 5, code: "a = 3;//00000000000000000000000000000011"},
        {id: 6, code: "a=255;//00000000000000000000000011111111"},
        {id: 7, text: "Если вам не понятны наличие этих нулей и единиц, а также их порядок, то очень рекомендую почитать или посмотреть о том как хранится информация в виде битов, вам сразу станет понятно почему. На YouTube доступны лекции Гарварда CS50, не все темы подходят под обучение языка JS, но основы которые они затрагивают фундаментальны для всех программистов."},
        {id: 8, title: "Побитовое И (AND)"},
        {id: 9, code: "0 and 0 = 0;"},
        {id: 10, code: "0 and 1 = 0;"},
        {id: 11, code: "1 and 0 = 0;"},
        {id: 12, code: "1 and 1 = 1;"},
        {id: 13, title: "Приведу пример:"},
        {id: 14, code: "let a = 1;"},
        {id: 15, code: "let b = 0;"},
        {id: 16, code: "if(a & b) {"},
        {id: 17, code: "ㅤㅤconsole.log(true);"},
        {id: 18, code: "} else {"},
        {id: 19, code: "ㅤㅤconsole.log(false);"},
        {id: 20, code: "};"},
        {id: 21, text: "Если хотя бы один из сравниваемых операндов не похож, то результат всегда будет false."},
        {id: 22, title: "Побитовое ИЛИ (OR)"},
        {id: 23, text: "Принцип напоминает работы логического &, однако здесь отличие в том, что, если хотя бы один из операндов соответствует условию, то результат будет true"},
        {id: 24, code: "let a = 1;"},
        {id: 25, code: "let b = 0;"},
        {id: 26, code: "if(a | b) {"},
        {id: 27, code: "ㅤㅤconsole.log(true);"},
        {id: 28, code: "} else {"},
        {id: 29, code: "ㅤㅤconsole.log(false);"},
        {id: 30, code: "};"},
        {id: 31, title: "Побитовое исключающее ИЛИ (XOR)"},
        {id: 32, text: "Если биты сравнивающихся операндов похожи, то есть равны 1, то они принимают значение 0, а те биты которые между операндами не равны оставляют за собой прежнее значение. И вот резутатом служит преобразование битов по их схожести между операндами. Ниже есть пример:"},
        {id: 33, code: "//9 = 00001001"},
        {id: 34, code: "//14 = 00001110"},
        {id: 35, code: "//32 = 00100000"},
        {id: 36, code: "14 ^ 9 = 00000111 = 7"},
        {id: 37, code: "14 ^ 9 ^ 32 = 00100111 = 39"},
        {id: 38, title: "Побитовое НЕ (NOT)"},
        {id: 39, text: "Говоря кратко, этот оператор преобразует биты операнда в совершенно противоположный результат, то есть превращает 0 в 1, а 1 в 0. Посмотрите пример:"},
        {id: 40, code: "//9 = 00001001"},
        {id: 41, code: "//14 = 00001110"},
        {id: 42, code: "//32 = 00100000"},
        {id: 43, code: "//9 = 00001001 => 11110110 = 246"},
        {id: 44, code: "//14 = 00001110 => 11110001 = 241"},
        {id: 45, code: "//32 = 00100000 => 11011111 = 223"},
        {id: 46, title: "Битовый сдвиг влево “<<”"},
        {id: 47, code: "1 << 2 //00000001 << 2 бита для свдвига"},
        {id: 48, code: "//4 //00000100"},
        {id: 49, code: "1 << 2 << 4 //00000001 -> 00000100 ->"},
        {id: 50, code: "01000000"},
        {id: 51, code: "// порядок сдвига идёт по цепочке"},
        {id: 52, text: "Этот оператор оперирует двумя операндами(если их больше, то всё идёт по порядку). Первый операнд это число биты которого должны быть сдвинуты, а второй операнд это количество битов на которые должен сдвинуться првый операнд. Посмотрите внимательно на пример, всё станет яснее."},
        {id: 53, title: "Битовый сдвиг вправо “>>”"},
        {id: 54, text: "Принцип действия такой же как у побидового сдвига влево, только направление вправо."},
        {id: 55, title: "Правый сдвиг с заполнением нулями “>>>”"},
        {id: 56, text: "По принципу действия очень похож с побитовым сдвигом вправо, однако при работе с отрицательными числами вы поймёте между ними разницу."},
        {id: 57, code: "-128 >> 5 // -4 = 00000100"},
        {id: 58, code: "-128 >>> 5 // 134217724 ="},
        {id: 59, code: "111111111111111111111111100"},
        {id: 60, code: "//до"},
        {id: 61, code: "//-128 = 111111111111111111111111|"},
        {id: 62, code: "10000000"},
        {id: 63, code: "//после вычисления"},
        {id: 64, code: "//134217724 ="},
        {id: 65, code: "00000111111111111111111111111100"},
        {id: 66, text: "Стоит обратить внимание, что при работе с отрицательными числами, то результат всегда выходит положительным. Обратите внимание на нули, сдвиг произошёл слева направо на 5 бит."}
    ],
    logicalOperationsLinkedPage: [
        {id: 1, themeName: "Логические операторы"},
        {id: 2, text: "В JS существует 3 вида логических операторов. Это “&&”(логическое И), “||” (логическое ИЛИ), “!” (логическое НЕ). Принцип действия первых двух операторов довольно схож с побитовыми операторами, за исключением того, что, побитовые операции отличаются от логических тем, что работают с двоичным представлением чисел."},
        {id: 3, code: "let int1 = 10;"},
        {id: 4, code: "let int2 = 2;"},
        {id: 5, code: "if(int1 / int2 !== 0){"},
        {id: 6, code: "ㅤㅤconsole.log(‘not 0’);"},
        {id: 7, code: "} else {"},
        {id: 8, code: "ㅤㅤconsole.log(‘equal 5’);"},
        {id: 9, code: "};"}
    ],
    ternaryOperatorLinkedPage: [
        {id: 1, themeName: "Тернарный оператор"},
        {id: 2, text: "Условный (тернарный) оператор - единственный оператор в JavaScript, принимающий три операнда: условие, за которым следует знак вопроса (?), затем выражение, которое выполняется, если условие истинно, сопровождается двоеточием (:), и, наконец, выражение, которое выполняется, если условие ложно. Он часто используется в качестве укороченного варианта условного оператора “if”."},
        {id: 3, code: "условие ? выражение1 : выражение2"},
        {id: 4, code: "let apples = 19;"},
        {id: 5, code: "let result;"},
        {id: 6, code: "result = (booksCount > 15) ? 'У нас много"},
        {id: 7, code: "яблок!' : 'Яблок на всех не хватит!';"},
        {id: 8, text: "То, что тернарные операторы позволяют писать условия компактней - это хорошо, однако визуально для некоторых людей они могут быть не понятны. Есть золотое правило: “...писать код так, чтобы он легко читался”. Код можно как то сделать код компактным, но главное знать меру. "}
    ],
    regularConditionalOperatorsLinkedPage: [
        {id: 1, themeName: "Операторы if, else if, else"},
        {id: 2, code: "let a = 34;"},
        {id: 3, code: "let b = 2;"},
        {id: 4, code: "let result;"},
        {id: 5, code: "if(a / n !== 17){"},
        {id: 6, code: "ㅤㅤresult = “not lucky number”;"},
        {id: 7, code: "} else if (a / n !== 15){"},
        {id: 8, code: "ㅤㅤresult = “not second lucky number”;"},
        {id: 9, code: "} else {"},
        {id: 10, code: "ㅤㅤresult = “lucky number”"},
        {id: 11, code: "};"},
        {id: 12, text: "Оператор “if” создаёт само условие, “else if” создаёт дополнительное условие, “else” создаёт прочие условия. “else if” может применяться множество раз, для описания ещё дополнительных условий."}
    ],
    switchOperatorLinkedPage: [
        {id: 1, themeName: "Операторы switch"},
        {id: 2, code: "let day = 6;"},
        {id: 3, code: "switch (day){ "},
        {id: 4, code: "ㅤㅤcase 6:console.log('weekend');break;"},
        {id: 5, code: "ㅤㅤcase 7:console.log('weekend');break"},
        {id: 6, code: "ㅤㅤdefault:console.log('work day'); "},
        {id: 7, code: "};"},
        {id: 8, text: "Конструкция switch заменяет собой сразу несколько if. Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами. Конструкция switch имеет один или более блок case и необязательный блок default."}
    ],
    arraysLinkedPage: [
        {id: 1, themeName: "Массивы"},
        {id: 2, title: "Способы создания массивов"},
        {id: 3, code: "let arr1 = [];"},
        {id: 4, code: "const arr2 = [2, -234, 9, -1];"},
        {id: 5, code: "let arr3 = new Array(2, -234, 9, -1);"},
        {id: 6, text: "Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений. Значениями могут быть и примитвные типы данных, так и сложные. Это значит, что вы можете передавать в массиве например не только числа и другие простые типы, но и объекты и массивы, которые могут хранить в себе и другие данные внутри.  Массивы представляют из себя упорядоченный список по индексам."},
        {id: 7, text: "Элементы массива нумеруются, начиная с нуля. Можно получить элемент, указав его номер в квадратных скобках."},
        {id: 8, code: "const arr1 = [5, -234, 9, -1];"},
        {id: 9, code: "let arr2 = [2, ‘hi’, 9, -1];"},
        {id: 10, code: "console.log(arr1[0]); // 5 "},
        {id: 11, code: "console.log(arr2[3]); // ‘hi’"},
        {id: 12, text: "Как и любой объект, массивами можно управлять с помощью методов. Методы массивов вы всегда можете найти на просторах интернета."}
    ],
    objectsLinkedPage: [
        {id: 1, themeName: "Объекты"},
        {id: 2, text: "Объекты используются для хранения коллекций различных значений и более сложных сущностей. В JavaScript объекты используются очень часто, это одна из основ языка. "},
        {id: 3, text: "Объекты имеют конструкцию из ключей и значений. В парадигме ООП(Объектно-ориентированное программирование) очень часто используется термин “сущность”, “атрибуты сущности”, ну а также “методы сущности”(под методами подразумеваются функции которые хранит объект(сущность))."},
        {id: 4, code: "let user1 = { "},
        {id: 5, code: `ㅤㅤname: "John",`},
        {id: 6, code: "ㅤㅤage: 20"},
        {id: 7, code: "};"},
        {id: 8, code: "let user2 = new Object();"},
        {id: 9, code: "let user3 = {...};"},
        {id: 10, text: "Выше приведены 3 примера создания объекта. Первый пример обладает ключами “name”, “age” и их значениями “John”, 20. Поскольку 20 числовой тип значения, он не требует каких либо кавычек. Во втором примере объект создаётся конструктором “new”. И наконец третий пример - это объявление литеральной нотацией."}
    ],
    setsLinkedPage: [
        {id: 1, themeName: "Сеты(множества)"},
        {id: 2, text: "Множества (sets) представляют структуру данных, которая может хранить только уникальные значения. В JavaScript функционал множества опредляет объект Set. Для создания множества применяется конструктор этого объекта."},
        {id: 3, code: "const arr = [1, 1, 2, 3, 4, 5, 2, 4];"},
        {id: 4, code: "const numbers = new Set(arr);"},
        {id: 5, code: "console.log(numbers);//Set(5) {1, 2, 3,"},
        {id: 6, code: "4, 5}"},
        {id: 7, text: "Пример добавления и удаления чисел при операции с “Set”."},
        {id: 8, code: "let numbers = new Set();"},
        {id: 9, code: "numbers.add(1);"},
        {id: 10, code: "numbers.add(-5);"},
        {id: 11, code: "numbers.delete(-5);"},
        {id: 12, code: "console.log(numbers);//Set(1) {1}"}
    ],
    mapsLinkedPage: [
        {id: 1, themeName: "Мапы(Map)"},
        {id: 2, text: "Map — это коллекция пар ключ/значение, которая может использовать любой тип данных в качестве ключа и поддерживает порядок своих записей. Карты содержат как характеристики объектов (коллекция пар ключ/значение), так и массивов (упорядоченная коллекция), но имеют больше сходства с объектами."},
        {id: 3, code: "const arr = [1, 1, 2, 3, 4, 5, 2, 4];"},
        {id: 4, code: "const numbers = new Set(arr);"},
        {id: 5, code: "console.log(numbers);//Set(5) {1, 2, 3,"},
        {id: 6, code: "4, 5}"},
        {id: 6, text: "new Map() - создаёт коллекцию."},
        {id: 7, text: "map.set(key, value) – записывает по ключу key значение value."},
        {id: 8, text: "map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует."},
        {id: 9, text: "map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false."},
        {id: 10, text: "map.delete(key)– удаляет элемент (пару «ключ/значение») по ключу key."},
        {id: 11, text: "map.clear() – очищает коллекцию от всех элементов."},
        {id: 12, text: "map.size – возвращает текущее количество элементов."}
    ],
    functionsLinkedPage: [
        {id: 1, themeName: "Функции"},
        {id: 2, code: "//стандартное объявление функции"},
        {id: 3, code: "function example1(аргумент1,аргумент2){"},
        {id: 4, code: "ㅤㅤ//действие 1"},
        {id: 5, code: "ㅤㅤ//действие 2"},
        {id: 6, code: "}"},
        {id: 7, code: "//объявление стрелочной функции"},
        {id: 8, code: "const example2 = (аргумент) => {"},
        {id: 9, code: "ㅤㅤ//действие 1"},
        {id: 10, code: "ㅤㅤ//действие 2"},
        {id: 11, code: "}"},
        {id: 12, code: "let a = 10;"},
        {id: 13, code: "let b = 10;"},
        {id: 14, code: "if(a === b){"},
        {id: 15, code: "ㅤㅤexample1()"},
        {id: 16, code: "} else {"},
        {id: 17, code: "ㅤㅤexample2()"},
        {id: 18, code: "}"},
        {id: 19, text: "Если после ключевого слова “function” не указывается название функции, то функция называется анонимной."}
    ]
}


export default state;